==Content handling mechanisms==

The task of detecting and handling various file types and encoding schemes is one of the most hairy and broken mechanisms in modern web browsers. This situation stems from the fact that for a longer while, virtually all browser vendors were trying to both ensure backward compatibility with `HTTP/0.9` servers (the protocol included absolutely no metadata describing any of the content returned to clients), and compensate for incorrectly configured `HTTP/1.x` servers that would return HTML documents with nonsensical `Content-Type` values, or unspecified character sets. In fact, having as many content detection hacks as possible would be perceived as a competitive advantage: the user would not care whose fault it was, if `example.com` rendered correctly in Internet Explorer, but not open in Netscape browser - Internet Explorer would be the winner.

As a result, each browser accumulated a unique and very poorly documented set of obscure content sniffing quirks that - because of no pressure on site owners to correct the underlying configuration errors - are now required to keep compatibility with existing content, or at least appear to be risky to remove or tamper with.

Unfortunately, all these design decisions preceded the arrival of complex and sensitive web applications that would host user content - be it baby photos or videos, rich documents, source code files, or even binary blobs of unknown structure (mail attachments). Because of the limitations of same-origin policies, these very applications would critically depend on having the ability to reliably and accurately instruct the browser on how to handle such data, without ever being second-guessed and having what meant to be an image rendered as HTML - and no mechanism to ensure this would be available.

This section includes a quick survey of key file handling properties and implementation differences seen on the market today. 

===Survey of content sniffing behaviors===

The first and only method for web servers to clearly indicate the purpose of a particular hosted resource is through the `Content-Type` response header. This header should contain a standard MIME specification of document type - such as `image/jpeg` or `text/html` - along with some optional information, such as the character set. In theory, this is a simple and bullet-proof mechanism. In practice, not very much so. 

The first problem is that - as noted on several occasions already - when loading many types of sub-resources, most notably for `<OBJECT>`, `<EMBED>`, `<APPLET>`, `<SCRIPT>`, `<IMG>`, `<LINK REL="...">`, or `<BGSOUND>` tags, as well as when requesting some plugin-specific, security-relevant data, the recipient would flat out ignore any values in `Content-Type` and `Content-Disposition` headers (or, amusingly, even HTTP status codes). Instead, the mechanism typically employed to interpret the data is as follows:

  * General class of the loaded sub-resource is derived from tag type. For example, `<IMG>` narrows the options down to a handful of internally supported image formats; and `<EMBED>` permits only non-native plugins to be invoked. Depending on tag type, a different code path is typically taken, and so it is impossible for `<IMG>` to load a Flash game, or `<EMBED>` to display a JPEG image.

  * The exact type of the resource is then decided based on MIME type hints provided in the markup, if supported in this particular case. For example, `<EMBED>` permits a `TYPE=` parameter to be specified to identify the exact plugin to which the data should be routed. Some tags, such as `<IMG>`, offer no provisions to provide any hints as to the exact image format used, however.

  * Any remaining ambiguity is then resolved in an implementation- and case-specific manner. For example, if `TYPE=` parameter is missing on `<EMBED>`, server-returned `Content-Type` may be finally examined and compared with the types registered by known plugins. On the other hand, on `<IMG>`, the distinction between JPEG and GIF would be made solely by inspecting the returned payload, rather than interpreting HTTP headers.

This mechanism makes it impossible for any server to opt out from having its responses passed to a variety of unexpected client-side interpreters, if any third-party page decides to do so. In many cases, misrouting the data in this manner is harmless - for example, while it is possible to construct a quasi-valid HTML document that also passes off as an image, and then load it via `<IMG>` tag, there is little or no security risk in allowing such a behavior. Some specific scenarios pose a major hazard, however: one such example is the infamous [http://blogs.zdnet.com/security/?p=1619 GIFAR flaw], where well-formed, user-supplied images could be also interpreted as Java code, and executed in the security context of the serving party.

The other problem is that although `Content-Type` is generally honored for any top-level content displayed in browser windows or within `<IFRAME>` tags, browsers are prone to second-guessing the intent of a serving party, based on factors that could be easily triggered by the attacker. Whenever any user-controlled file that never meant to be interpreted as HTML is nevertheless displayed this way, an obvious security risk arises: any Javascript embedded therein would execute in the security context of the hosting domain.

The exact logic implemented here is usually contrived and as poorly documented - but based on our current knowledge, could be generalized as:

  * If HTTP `Content-Type` header (or other origin-provided MIME type information) is available *and* parses cleanly, it is used as a starting point for further analysis. The syntax for `Content-Type` values is only vaguely outlined in [http://tools.ietf.org/rfc/rfc2045.txt RFC 2045], but generally the value should match a regex of "`[a-z0-9\-]+/[a-z0-9\-]+`" to work properly.<p />Note that protocols such as `javascript:`, `file://`, or `ftp://` do not carry any associated MIME type information, and hence will not satisfy this requirement. This behavior causes the behavior of downloaded files to be potentially very different from that of the same files served over HTTP.

  * If `Content-Type` data is not available or did not parse, most browsers would try to guess how to handle the document, based on implementation- and case-specific procedures, such as scanning the first few hundred bytes of a resource, or examining apparent file extension on the end of URL path (or in query parameters), then matching it against system-wide list (`/etc/mailcap`, Windows registry, etc), or a builtin set of rules.<p />Note that due to mechanisms such as `PATH_INFO`, `mod_rewrite`, and other server and application design decisions, the apparent path - used as a content sniffing signal - may often contain bogus, attacker-controlled segments.

  * If `Content-Type` matches one of generic values, such as `application/octet-stream`, `application/unknown`, or even `text/plain`, many browsers treat this as a permission to second-guess the value based on the aforementioned signals, and try to come up with something more specific. The rationale for this step is that some badly configured web servers fall back to these types on all returned content.

  * If `Content-Type` is valid but not recognized - for example, not handled by the browser internally, not registered by any plugins, and not seen in system registry - some browsers may again attempt to second-guess how to handle the resource, based on a more conservative set of rules.

  * For certain `Content-Type` values, browser-specific quirks may also kick in. For example, Microsoft Internet Explorer 6 would try to detect HTML on any `image/png` responses, even if a valid PNG signature is found (this was recently fixed).

  * At this point, the content is either routed to the appropriate renderer, or triggers an open / download prompt if no method to internally handle the data could be located.<p>An important caveat is that if `Content-Type` indicates any of XML document varieties, the content may be routed to a general XML parser and interpreted in a manner inconsistent with the apparent `Content-Type` intent. For example, `image/svg+xml` may be rendered as XHTML, depending on top-level or nested XML namespace definitions, despite the fact that `Content-Type` clearly states a different purpose.

As it is probably apparent by now, not much thought or standardization was given to browser behavior in these areas previously. To further complicate work, the documentation available on the web is often outdated, incomplete, or inaccurate ([https://developer.mozilla.org/en/How_Mozilla_determines_MIME_Types Firefox docs] are an example). Following widespread complaints, current [http://www.w3.org/html/wg/html5/ HTML 5 drafts] attempt to take at least some content handling considerations into account - although these rules are far from being comprehensive. Likewise, some improvements to specific browser implementations are being gradually introduced (e.g., [http://msdn.microsoft.com/en-us/library/cc994329(VS.85).aspx image/* behavior changes]), while other were resisted (e.g., [http://blogs.msdn.com/ie/archive/2005/02/01/364581.aspx fixing text/plain logic]).

Some of the interesting corner cases of content sniffing behavior are captured below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is HTML sniffed when no `Content-Type` received?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Content sniffing buffer size when no `Content-Type` seen</font> || 256 B || <font color="#ff0000">∞</font> || || 1 kB || 1 kB || 1 kB || <font color="#ff0000">~130 kB</font> || 1 kB || <font color="#ff0000">∞</font> ||
|| <font color="#3050a0">Is HTML sniffed when a non-parseable `Content-Type` value received?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Is HTML sniffed on `application/octet-stream` documents?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO ||
|| <font color="#3050a0">Is HTML sniffed on `application/binary` documents?</font> || NO || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is HTML sniffed on `*/unknown` documents?</font> || NO || NO || || NO || NO || NO || NO || YES || NO || 
|| <font color="#3050a0">Is HTML sniffed on MIME types not known to browser?</font> || NO || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is HTML sniffed on unknown MIME when `.html` seen in URL parameters?</font> || <font color="#ff0000">YES</font> || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is HTML sniffed on unknown MIME when `.html` seen in URL path?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is HTML sniffed on `text/plain` documents under any circumstances?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is HTML sniffed on GIF served as `image/jpeg`?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Content sniffing buffer size for second-guessing MIME type</font> || 256 B || 256 B || || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">May image/svg+xml document contain HTML xmlns payload?</font> || <font color="#ff0000">(YES)</font> || <font color="#ff0000">(YES)</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">(YES)</font> ||
|| <font color="#3050a0">HTTP error codes ignored on sub-resources?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||

In addition, the behavior for non-HTML resources is as follows (to test for these, please put sample HTML inside two files with extensions of =.TXT= and =.UNKNOWN=, then attempt to access them through the browser):

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">File type detection for `ftp://` resources</font> || content sniffing || content sniffing || || content sniffing || content sniffing || content sniffing || <font color="#30ff30">extension matching</font> || content sniffing || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">File type detection for `file://` resources</font> || content sniffing || <font color="#30ff30">sniffing w/o HTML</font> || || content sniffing || content sniffing || content sniffing || content sniffing || <font color="#30ff30">extension matching</font> || <font color="#909090">tbd</font> ||

<b></b>

===Downloads and Content-Disposition===

Browsers automatically present the user with the option to download any documents for which the returned `Content-Type` is:

  * Not claimed by any internal feature,
  * Not recognized by MIME sniffing or extension matching routines,
  * Not handled by any loaded plugins,
  * Not associated with a whitelisted external program (such as a media player).

Quite importantly, however, the server may also explicitly instruct the browser not to attempt to display a document inline by employing [http://www.ietf.org/rfc/rfc2183.txt RFC 2183] `Content-Disposition: attachment` functionality. This forces a download prompt even if one or more of the aforementioned criteria is satisfied - but only for top-level windows and `<IFRAME>` containers.

An explicit use of `Content-Disposition: attachment` as a method of preventing inline rendering of certain documents became a commonly employed _de facto_ security feature. The most important property that makes it useful for mitigating the risk of content sniffing is that when included in HTTP headers returned for `XMLHttpRequest`, `<SCRIPT SRC="...">`, or <`IMG SRC="...">` callbacks, it has absolutely no effect on the intended use; but it prevents the attacker from making any direct reference to these callbacks in hope of having them interpreted as HTML.

Closer to its intended use - triggering browser download prompts in response to legitimate and expected user actions - `Content-Disposition` offers fewer benefits, and any reliance on it for security purposes is a controversial practice. Although such a directive makes it possible to return data such as unsanitized `text/html` or `text/plain` without immediate security risks normally associated with such operations, it is not without its problems:

  * *Real security gain might be less than expected:* because of the relaxed security rules for `file://` URLs in some browsers - including the ability to access arbitrary sites on the Internet - the benefit of having the user save a file prior to opening it might be illusory: even though the original context is abandoned, the new one is powerful enough to wreak the same havoc on the originating site.<p />Recent versions of Microsoft Internet Explorer mitigate the risk by storing [http://msdn.microsoft.com/en-us/library/ms537628(VS.85).aspx mark-of-the-web] and [http://msdn.microsoft.com/en-us/library/ms537029(VS.85).aspx ADS Zone.Identifier] tags on all saved content; the same practice is followed by Chrome. These tags are later honored by Internet Explorer, Windows Explorer, and a handful of other Microsoft applications to either restrict the permissions for downloaded files, or display security warnings and request a confirmation prior to displaying the data. Any benefit of these mechanisms is lost if the data is stored or opened using a third-party browser, or sent to any other application that does not carry out additional checks, however.

  * *Loss of MIME metadata may turn harmless files into dangerous ones:* `Content-Type` information is discarded the moment a resource is saved to disk. Unless a careful control is exercised either by the explicit `filename=` field included in `Content-Disposition` headers, or the name derived from apparent URL path, undesired content type promotion may occur (e.g., JPEG becoming an EXE that, to the user, appears to be coming from `www.example-bank.com` or other trusted site). Some, but not all, browsers take measures to mitigate the risk by matching `Content-Type` with file extensions prior to saving files.

  * *No consistent rules for escaping cause usability concerns:* certain characters are dangerous in `Content-Disposition` headers, but not necessarily undesirable in local file names (this includes `"` and `;`, or high-bit UTF-8). Unfortunately, there is no reliable approach to encoding non-ASCII values in this header: some browsers support [http://www.faqs.org/rfcs/rfc2047.html RFC 2047] (`?q?` / `?b?` notation), some support [http://www.faqs.org/rfcs/rfc2231.html RFC 2231] (a bizarre `*=` syntax), some support stray `%nn` hexadecimal encoding, and some do not support any known escaping scheme at all. As a result, quite a few applications take potentially insecure ways out, or cause problems in non-English speaking countries.

  * *Browser bugs further contribute to the misery:* browsers are plagued by implementation flaws even in such a simple mechanism. For example, Opera ignores `Content-Disposition: attachment` after the initial correctly handled attempt to open a resource, while Microsoft Internet Explorer violates [http://www.ietf.org/rfc/rfc2183.txt RFC 2183] and [http://www.ietf.org/rfc/rfc2045.txt RFC 2045] by stopping file name parsing on first `;` character, even within a quoted string (e.g., `Content-Disposition: attachment; filename="hello.exe;world.jpg"` → `"hello.exe"`). Historically, Microsoft Internet Explorer 6, and Safari permitted `Content-Disposition` to be bypassed altogether, too, although these problems appear to be fixed. In Opera, the behavior appears to be inconsistent.

Several tests that outline key `Content-Disposition` handling differences are shown below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is `Content-Disposition` supported correctly?</font> || YES || YES || || YES || YES || YES || <font color="#ff0000">NO</font> || YES || YES ||
|| <font color="#3050a0">Is Mark-of-the-Web / Zone.Identifier supported?</font> || <font color="#30ff30">YES</font> || <font color="#30ff30">YES</font> || || NO || NO || NO || NO || <font color="#30ff30">write-only</font> || NO ||
|| <font color="#3050a0">Types of file name encodings supported</font> || `%nn` || `%nn` || || `?b? ?q? *=` || `?b? ?q? *=` || `*=` || `*=` || `?b? ?q? %nn` || <font color="#ff0000">none</font> ||
|| <font color="#3050a0">Does `filename=test.html` override `Content-Type`?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Does `filename=test.exe` override `Content-Type`?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || YES ||
|| <font color="#3050a0">Does URL-derived `test.html` filename override `Content-Type`?</font> || <font color="#ff0000">YES</font> || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Does URL-derived `test.exe` filename override `Content-Type`?</font> || <font color="#ff0000">YES</font> || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || YES ||
|| <font color="#3050a0">Is `;` handled correctly in file names?</font> || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || || YES || YES || YES || YES || YES || YES ||

<b></b>

===Character set handling and detection===

When displaying any renderable, text-based content - such as `text/html`, `text/plain`, and many others - browsers are capable of recognizing and interpreting a large number of both common and relatively obscure character sets. Some of the most important cases include:

  * A basic fixed-width 7-bit `us-ascii` charset ([http://www.columbia.edu/kermit/ascii.html reference]). The charset is defined only for character values of `\x00` to `\x7F`, although it is technically transmitted as 8-bit data. High bit values are not permitted; in practice, if they appear in text, their most significant bit may be zeroed upon parsing, or they may be treated as `iso-8859-1` or any other 8-bit encoding.

  * An assortment of legacy, fixed-width 8-bit character sets built on top of `us-ascii` by giving a meaning to character codes of `\x80` to `\xFF`. Examples here include `iso-8859-1` (default fallback value for most browsers) and the rest of `iso-8859-*` family, `KOI8-*` family, `windows-*` family, and so forth. Although different glyphs are assigned to the same 8-bit code in each variant, all these character sets are identical from the perspective of document structure parsing.

  * A range of non-Unicode variable-width encodings, such as [http://en.wikipedia.org/wiki/Shift-JIS Shift-JIS], [http://en.wikipedia.org/wiki/EUC-JP EUC-* family], [http://en.wikipedia.org/wiki/Big5 Big5], and so forth. In a majority of these encodings, single bytes in the `\x00` to `\x7F` range are used to represent `us-ascii` values, while high-bit and multibyte values represent more complex non-Latin characters.

  * A now-common variable-width 8-bit `utf-8` encoding scheme ([http://en.wikipedia.org/wiki/UTF-8 reference]), where special prefixes of `\x80` to `\xFD` are used on top of `us-ascii` to begin high-bit multibyte sequences of anywhere between 2 and 6 bytes, encoding a full range of [http://en.wikipedia.org/wiki/Unicode Unicode] characters.

  * A less popular variable-width 16-bit `utf-16` encoding ([http://en.wikipedia.org/wiki/UTF-16 reference]), where single words are used to encode `us-ascii` and the primary planes of Unicode, and word pairs are used to encode supplementary planes. The encoding has little and big endian flavors. 

  * A somewhat inefficient, fixed-width 32-bit `utf-32` encoding ([http://en.wikipedia.org/wiki/UTF-32 reference]), where every Unicode character is stored as a double word. Again, little and big endian flavors are present.

  * An unusual variable-width 7-bit `utf-7` encoding scheme ([http://en.wikipedia.org/wiki/UTF-7 reference]) that permits any Unicode characters to be encoded using `us-ascii` text using a special `+...-` string. Literal `+` and some other values (such as `~` or `\`) must be encoded likewise. Behavior on stray high bit characters may vary, similar to that of `us-ascii`.

There are multiple security considerations for many of these schemes, including:

  * Unless properly accounted for, any scheme that may clip high bit values could potentially cause unexpected control characters to appear in unexpected places. For example, in `us-ascii`, a high-bit character of `\xBC` (`ź`), appearing in user input, may suddenly become `\x3C` (`<`). This does not happen in modern browsers for HTML parsing, but betting on this behavior being observed everywhere is not a safe assumption to make.

  * Unicode-based variable-width `utf-7` and `utf-8` encodings technically make it permit to encode `us-ascii` values using multibyte sequences - for example, `\xC0\xBC` in `utf-8`, or `+ADw-` in `utf-7`, may both decode to `\x3C` (`<`). Specifications formally do not permit such notation, but not all parsers pay attention to this requirement. Modern browsers tend to reject such syntax for some encodings, but not for others.

  * Variable-width decoders may indiscriminately consume a number of bytes following a multibyte sequence prefix, even if not enough data was in place to begin with - potentially causing portions of document structure to disappear. This may easily result in server's and browser's understanding of HTML structure getting dangerously out of sync. With `utf-8`, most browsers follow avoid over-consumption of non-high-bit values; with `utf-7`, `EUC-JP`, `Big5`, and many other legacy or exotic encodings, this is not always the case.

  * All Unicode-based encodings permit certain special codes that function as layout controls to be encoded. Some of these controls override text display direction or positioning ([http://unicode.org/charts/PDF/U2000.pdf reference]). In some uses, permitting such characters to go through might be disruptive.

The pitfalls of specific, mutually negotiated encodings aside, any case where server's understanding of the current character set might be not in sync with that of the browser is a disaster waiting to happen. Since the same string might have very different meanings depending on which decoding procedure is applied to it, the document might be perceived very differently by the generator, and by the renderer. Browsers tend to auto-detect a wide variety of character sets (see: [http://msdn.microsoft.com/en-us/library/ms537500(VS.85).aspx Internet Explorer list], [http://www.mozilla.org/projects/intl/chardet.html Firefox list]) based on very liberal and undocumented heuristics, historically including even parent character set inheritance ([http://www.hardened-php.net/advisory_032007.142.html advisory]); just as frighteningly, Microsoft Internet Explorer applies character set auto-detection prior to content sniffing.

This behavior makes it inherently unsafe to return any renderable, user-controlled data with no character set explicitly specified. There are two primary ways to explicitly declare a character set for any served content; first of them is the inclusion of a `charset=` attribute in `Content-Type` headers:

{{{
Content-Type: text/html; charset=utf-8
}}}

The other option is an equivalent `<META HTTP-EQUIV="...">` directive (supported for HTML only):

{{{
<META HTTP-EQUIV="Content-Type" CONTENT="text/plain; charset=utf-8">
}}}

_NOTE: Somewhat confusingly, XML `<?xml version="1.0" encoding="UTF-8">` directive does not authoritatively specify the character set for the purpose of rendering XHTML documents - in absence of one of the aforementioned declarations, character set detection may still take place regardless of this tag._

That said, if an appropriate character set declaration is provided, browsers thankfully tend to obey a specified character set value, with two caveats:

  * Invalid character set names cause character set detection to kick in. Sadly, there is little or no consistency in how flexibly character set name might be specified, leading to unnecessary mistakes - for example, `iso-8859-2` and `iso8859-2` are both a valid character set to most browsers, and so many developers learned to pay no attention to how they enter the name; but `utf8` is *not* a valid alias for `utf-8`. 

  * As noted in the section on [http://code.google.com/p/browsersec/wiki/Main#Hypertext_Markup_Language HTML language], the precedence of `META HTTP-EQUIV` and `Content-Type` character specifications is not well-defined in any specific place - so if the two directives disagree, it is difficult to authoritatively predict the outcome of this conflict in all current and future browsers.

Relevant tests:


===Document caching===

==Defenses against disruptive scripts==

===Popup and dialog filtering logic===

===Window appearance restrictions===

===Execution timeouts and memory limits===

===Page transition logic===

==Protocol-level encryption facilities==

=Experimental and legacy security mechanisms=

==HTTP authentication==

==Microsoft Internet Explorer zone model==

==Microsoft Internet Explorer frame restrictions==

==Microsoft Internet Explorer XSS filtering==

==Script restriction frameworks==

==Origin headers==

==Mozilla content security policies==

=Open browser engineering issues=

=Acknowledgments=