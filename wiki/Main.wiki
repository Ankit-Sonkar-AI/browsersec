#summary Main wiki page
#labels Featured

<h1>Browser Security Handbook</h1>

  * Written and maintained by [http://lcamtuf.coredump.cx/ Michal Zalewski] <[mailto:lcamtuf@google.com lcamtuf@google.com]>. 
  * Copyright 2008 Google Inc, rights reserved.
  * Released under terms and conditions of the [http://creativecommons.org/licenses/by/3.0 CC-3.0-BY] license.

<h1>Table of Contents</h1>

<wiki:toc max_depth="10" />

=Introduction=

Hello, and welcome to the _Browser Security Handbook_!

This document is meant to provide web application developers, browser engineers, and information security researchers with a one-stop reference to key security properties of contemporary web browsers. Insufficient understanding of these often poorly-documented characteristics is a major contributing factor to the prevalence of several classes of security vulnerabilities.

Although all browsers implement roughly the same set of baseline features, there is relatively little conformance to standards when it comes to many of the less apparent characteristics. Furthermore, vendors routinely introduce poorly documented, proprietary tweaks or improvements that may interfere with existing features in non-obvious ways.

The current version of this document is based on the following versions of web browsers:

|| <font color="#3050a0">*Browser*</font> || <font color="#3050a0">*Version*</font> || <font color="#3050a0">*Test date*</font> || <font color="#3050a0">*Usage*</font>^*^ || <font color="#3050a0">*Notes*</font> ||
|| Microsoft Internet Explorer 6 || 6.0.2900.5512 || Nov 18, 2008 || 23% || ||
|| Microsoft Internet Explorer 7 || 7.0.5730.11 || Nov 18, 2008 || 47% || ||
|| <font color="#909090">Microsoft Internet Explorer 8 (beta)</font> || || || <font color="#909090">n/a</font> || <font color="#909090">Not tested - pending release.</font> ||
|| Mozilla Firefox 2 || 2.0.0.17 || Nov 6, 2008 || 5% || ||
|| Mozilla Firefox 3 || 3.0.3 || Nov 18, 2008 || 15% || ||
|| Apple Safari || 3.2 || Nov 18, 2008 || 5% || ||
|| Opera || 9.62 || Nov 18, 2008 || ~1% || ||
|| Google Chrome || 0.3.154.9 || Nov 18, 2008 || ~1% || ||
|| Android  embedded browser || SDK 1.0 RC1 || Nov 10, 2008 || <font color="#909090">n/a</font> || Tests requiring `file:///` targets not executed. ||

^*^ Approximate browser usage data based on public [http://marketshare.hitslink.com/report.aspx?qprid=3 Net Applications] estimates for October 2008.

=Disclaimers and typographical conventions=

*Please note that although we tried to make this document as accurate as possible, some errors might have slipped through. Use this document only as an initial reference, and independently verify any characteristics you wish to depend upon. All the test cases featured in this document are [http://browsersec.googlecode.com/files/browser_tests-1.0.tar.gz freely available for download].*

The document attempts to capture the risks and security considerations present for general populace of users accessing the web with default browser settings in place. Although occasionally noted, the degree of flexibility offered through non-standard settings is by itself not a subject of this comparative study.

Through the document, <font color="#ff0000">red color</font> is used to bring attention to browser properties seeem particularly tricky or unexpected, and need to be carefully accounted for in server-side implementations. Whenever status quo appears to bear no significant security consequences and is well-understood, but a particular browser implementation takes additional steps to protect application developers, we use <font color="#30ff30">green color</font> to denote this, likewise. Rest assured, neither of these color codes implies that a particular browser is less or more secure than its counterparts.

=Basic concepts behind web browsers=

This section provides a review of core standards and technologies behind current browsers, and their security-relevant properties. No specific attention is given to features implemented explicitly for security purposes; these are discussed in later in the document.

==Uniform Resource Locators==

All web resources are addressed with the use of uniform resource identifiers. Being able to properly parse the format, and make certain assumptions about the data present therein, is of significance to many server-side security mechanisms.

The abstract syntax for URIs is described in [http://www.ietf.org/rfc/rfc3986.txt RFC 3986]. The document defines a basic hierarchical URI structure, defining a white list of unreserved characters that may appear in URIs as-is as element names, with no particular significance assigned (`0-9 A-Z a-z - . _ ~`), spelling out reserved characters that have special meanings and can be used in some places only in their desired function (`: / ? # [ ] @ ! $ & ' ( ) * + , ; =`), and establishing a hexadecimal percent-denoted encoding (`%nn`) for everything outside these sets (including the stray `%` character itself).

Some additional mechanisms are laid out in [http://www.ietf.org/rfc/rfc1738.txt RFC 1738], which defines URI syntax within the scope of HTTP, FTP, NNTP, Gopher, and several other specific protocols. Together, these RFCs define the following syntax for common Internet resources (the compliance with a generic naming strategy is denoted by the `//` prefix):

{{{
scheme://[authority[:password]@](host_name|\[host_address\])[:port][/hierarchical/path/to/resource[?search_string][#fragment_id]]
}}}

Since the presence of a scheme is the key differentiator between relative references permitted in documents for usability reasons, and fully-qualified URLs, and since `:` itself has other uses later in the URL, the set of characters permitted for scheme name must be narrow and clearly defined (`0-9 A-Z a-z + - .`) so that all implementations may make the distinction accurately.

On top of the aforementioned documents, a W3C draft [http://www.w3.org/Addressing/rfc1630.txt RFC 1630] outlines some additional concepts, such as the exact HTTP search string syntax (`param1=val1[&param2=val2&...]`), or the ability to use the `+` sign as a shorthand notation for spaces (the character itself does not function in this capacity elsewhere in the URL, which is somewhat counterintuitive).

In practice, browsers deviate from these standards in many ways, for example accepting URLs with technically forbidden, and then trying to escape them automatically; or applying heuristics to handle incomplete or seemingly broken URLs. Here are some of the key differences that often need to be accounted for:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Non-standard characters permitted in URL scheme fields (excluding `0-9 A-Z a-z + - .`)</font> || \t \r \n || \t \r \n || || \t \r \n || \t \r \n || <font color="#909090">none</font> || \r \n <font color="#ff0000">+UTF8</font> || <font color="#ff0000">\0</font> \t \r \n || <font color="#909090">none</font> ||
|| <font color="#3050a0">Non-standard characters kept as-is, with no escaping, in URL queries (excluding `0-9 A-Z a-z - . _ ~ : / ? # [ ] @ ! $ & ' ( ) * + , ; =`)</font> || <font color="#ff0000">" < > \</font> ^ ` { | } \x7F || <font color="#ff0000">" < > \</font> ^ ` { | } \x7F || || <font color="#ff0000">\</font> ^ { | } || <font color="#ff0000">\</font> ^ { | } || ^ { | } || ^ { | } \x7F || <font color="#ff0000">" \</font> ^ ` { | } || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">Non-standard characters fully ignored in host names</font> || \t \r \n || \t \r \n \xAD || || \t \r \n \xAD || \t \r \n \xAD || \xAD || \x0A-\x0D \xA0 \xAD || \t \r \n \xAD || <font color="#909090">none</font> ||
|| <font color="#3050a0">Types of partial or broken URLs auto-corrected to fully qualified ones</font> || //y \\y || //y \\y || || //y x:///y x://`[y]` || //y x:///y x://`[y]` || //y \\y x:/y x:///y || //y \\y x://`[y]` || //y \\y x:///y || //y \\y ||
|| <font color="#3050a0">Is fragment ID (hash) encoded by applying RFC-mandated URL escaping rules?</font> || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || || <font color="#ff0000">PARTLY</font> || <font color="#ff0000">PARTLY</font> || YES || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || YES ||

_NOTE: As an anti-phishing mechanism, additional restrictions on the use of `authority` and `password` fields in URLs are imposed by many browsers; see the section on [#HTTP_authentication HTTP authentication] later on._

Please note that when links are embedded within HTML documents, [http://www.w3.org/TR/REC-html40/charset.html#h-5.3.2 HTML entity decoding] takes place before the link is parsed. Because of this, if a newline is ignored in URL schemes, a link such as `javascript&#09;:alert(1)` may be accepted and executed as Javascript, just as `javascript<TAB>:alert(1)` would be.

===Unicode in URLs===

Much like several related technologies used for web content transport, URLs do not have any particular character set defined by relevant RFCs; [http://www.ietf.org/rfc/rfc3986.txt RFC 3986] ambiguously states: _"In local or regional contexts and with improving technology, users might benefit from being able to use a wider range of characters; such use is not defined by this specification."_ The same dismissive approach is taken in HTTP header specification.

As a result, in the context of web URLs, any high-bit user input may and should be escaped as `%nn` sequences, but there is no specific guidance provided on how to transcode user input in system's native code page when talking to other parties that may not share this code page. On a system that uses UTF-8 and receives a URL containing Unicode `ą` in the path, this corresponds to a sequence of `0xC4 0x85` natively; however, when sent to a server that uses `ISO-8859-2`, the correct value sent should be `0xB1` (or alternatively, additional information about client-specific encoding should be included to make the conversion possible on server side). In practice, most browsers deal with this by sending UTF-8 data by default on any text entered in the URL bar by hand, and using page encoding on all followed links.

Another limitation of URLs traces back to DNS as such; [http://www.ietf.org/rfc/rfc1035.txt RFC 1035] permits only characters `A-Z a-z 0-9 -` in DNS labels, with period (`.`) used as a delimiter; some resolver implementations further permit underscore (`_`) to appear in DNS names, violating the standard, but other characters are almost universally banned. With the growth of the web, the need to accommodate non-Latin alphabets in host names was perceived by multiple parties - and the use of `%nn` encoding was not an option, because `%` as such was not on the list.

To solve this, [http://tools.ietf.org/html/rfc3490 RFC 3490] lays out a rather contrived encoding scheme that permitted Unicode data to be stored in DNS labels, and [http://tools.ietf.org/html/rfc3492 RFC 3492] outlines a specific implementation within DNS labels - commonly referred to as Punycode - that follows the notation of `xn--[US-ASCII part]-[encoded Unicode data]`. Any Punycode-aware browser faced with non US-ASCII data in a host name is expected to transform it to this notation first, and then perform a traditional DNS lookup for the encoded string.

Putting these two methods together, the following transformation is expected to be made internally by the browser:

{{{
http://www.ręczniki.pl/?ręcznik=1 → http://www.xn--rczniki-98a.pl/?r%C4%99cznik=1
}}}

Key security-relevant differences in high-bit URL handling are outlined below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Request URL path encoding when following plain links</font> || UTF-8 || UTF-8 || || page encoding || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 ||
|| <font color="#3050a0">Request URL query string encoding when following plain links</font> || <font color="#ff0000">page encoding, no escaping</font> || <font color="#ff0000">page encoding, no escaping</font> || || page encoding || page encoding || page encoding || page encoding || page encoding || page encoding ||
|| <font color="#3050a0">Request URL path encoding for `XMLHttpRequest` calls</font> || page encoding || page encoding || || page encoding || page encoding || page encoding || page encoding || page encoding || page encoding ||
|| <font color="#3050a0">Request URL query string encoding for `XMLHttpRequest` calls</font> || <font color="#ff0000">page encoding, no escaping</font> || <font color="#ff0000">page encoding, no escaping</font> || || page encoding || page encoding || <font color="#ff0000">mangled</font> || page encoding || <font color="#ff0000">mangled</font> || <font color="#ff0000">mangled</font> || 
|| <font color="#3050a0">Request URL path encoding for manually entered URLs</font> || UTF-8 || UTF-8 || || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 ||
|| <font color="#3050a0">Request URL query string encoding for manually entered URLs</font> || <font color="#ff0000">transcoded to 7 bit</font> || <font color="#ff0000">transcoded to 7-bit</font> || || UTF-8 || UTF-8 || UTF-8 || <font color="#ff0000">stripped to `?`</font> || UTF-8 || UTF-8 ||
|| <font color="#3050a0">Raw Unicode in host names auto-converted to Punycode?</font> || NO || YES || || YES || YES || YES || YES || YES || NO ||
|| <font color="#3050a0">Is percent-escaped UTF-8 in host names auto-converted to Punycode?</font> || (NO) || YES || || <font color="#ff0000">NO</font> || <font color="#ff0000">on retry</font> || YES || YES || YES || (NO) ||
|| <font color="#3050a0">URL bar Unicode display method for host names</font> || (Punycode) || Unicode || || Unicode || Unicode || Unicode || Unicode || Punycode || (Punycode) ||
|| <font color="#3050a0">URL bar Unicode display method outside host names</font> || Unicode || Unicode || || `%nn` || Unicode || Unicode || as `?` || Unicode || <font color="#909090">n/a</font> ||

 
_NOTE: As an anti-phishing mechanism, additional restrictions on the use of some or all Unicode characters in certain top-level domains are imposed by many browsers; see [#International_Domain_Name_checks domain name restrictions] chapter later on._

==True URL schemes==

URL schemes are used to indicate what general protocol needs to be used to retrieve the data, and how the information needs to be processed for display. Schemes may also be tied to specific default values of some URL fields - such as a TCP port - or specific non-standard URL syntax parsing rules (the latter is usually denoted by the absence of a `//` string after scheme identifier).

Back in 1994, [http://www.ietf.org/rfc/rfc1738.txt RFC 1738] laid out several URL schemes in the context of web browsing, some of which are not handled natively by browsers, or have fallen into disuse. As the web matured, multiple new open and proprietary schemes appeared with little or no consistency, and the set of protocols supported by each browser began to diverge. [http://www.ietf.org/rfc/rfc2718.txt RFC 2718] attempted to specify some ground rules for the creation of new protocols, and [http://www.ietf.org/rfc/rfc4395.txt RFC 4395] mandated that new schemes be registered with IANA (their list is [http://www.iana.org/assignments/uri-schemes.html available here]). In practice, however, few parties could be bothered to follow this route.

To broadly survey the capabilities of modern browsers, it makes sense to divide URL schemes into a group natively supported by the software, and another group supported by a plethora of plugins, extensions, or third-party programs. The first list is relatively short:

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">HTTP ([http://www.ietf.org/rfc/rfc2616.txt RFC 2616])</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">HTTPS ([http://www.ietf.org/rfc/rfc2616.txt RFC 2818])</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">SHTTP ([http://www.ietf.org/rfc/rfc2660.txt RFC 2660])</font> || as HTTP || as HTTP || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">FTP ([http://www.ietf.org/rfc/rfc1738.txt RFC 1738])</font> || YES || YES || || YES || YES || YES || YES || YES || NO ||
|| <font color="#3050a0">file ([http://www.ietf.org/rfc/rfc1738.txt RFC 1738])</font> || YES || YES || || YES (local) || YES (local) || YES (local) || YES || YES || _tbd_ ||
|| <font color="#3050a0">Gopher ([http://www.ietf.org/rfc/rfc14266.txt RFC 4266])</font> || NO || NO || || YES || YES || NO || defunct? || NO || NO ||
|| <font color="#3050a0">news ([http://tools.ietf.org/html/draft-ellermann-news-nntp-uri-11 draft RFC])</font> || NO || NO || || NO || NO || NO || YES || NO || NO ||

These protocols may be used to deliver natively rendered content that is interpreted and executed using the security rules implemented within the browsers.

The other list, third-party protocols routed to other applications, depends quite heavily on system configuration. The set of protocols and their handlers is usually maintained in a separate system-wide registry. Browsers may whitelist some of them by default (executing external programs without prompting), or blacklist some (preventing their use altogether); the default action is often to display a mildly confusing prompt. Most common protocols in this family include:

{{{
acrobat                           - Acrobat Reader
callto                            - some instant messengers, IP phones
daap / itpc / itms / ...          - Apple iTunes
FirefoxURL                        - Mozilla Firefox
hcp                               - Microsoft Windows Help subsystem
ldap                              - address book functionality
mailto                            - various mail agents
mmst / mmsu / msbd / rtsp / ...   - streaming media of all sorts
mso-offdap                        - Microsoft Office
news / snews / nntp               - various news clients
outlook / stssync                 - Microsoft Outlook
rlogin / telnet / tn3270          - telnet client
shell                             - Windows Explorer
sip                               - various IP phone software
}}}

New handlers might be registered in OS- and application-specific ways, for example by registering new `HKCR\Protocols\Handlers` keys in Windows registry, or adding `network.protocol-handler.*` settings in Firefox.

As a rule, the latter set of protocols is not honored within the renderer when referencing document elements such as images, script or applet sources, and so forth; they do work, however, as `<IFRAME>` and link targets, and will launch a separate program as needed. These programs may sometimes integrate seamlessly with the renderer, but the rules by which they render content and impose security restrictions are generally unrelated to the browser as such.

Historically, the ability to plant such third-party schemes in links proved to be a significant exploitation vector, as poorly written, vulnerable external programs often register protocol handlers without user's knowledge or consent; as such, it is prudent to reject unexpected schemes where possible, and exercise caution when introducing new ones on client side (including observing [http://www.securityfocus.com/bid/24837/ safe parameter passing conventions]).

==Pseudo URL schemes==

In addition to the aforementioned "true" URL schemes, modern browsers support a large number of pseudo-schemes used to implement various advanced features, such as encapsulating encoded documents within URLs, providing legacy scripting features, or giving access to internal browser information and data views.

Encapsulating schemes are of interest to any link-handling applications, as these methods usually impose specific non-standard content parsing or rendering modes on top of existing resources specified in the later part of the URL. The underlying content is retrieved using HTTP, looked up locally (e.g., `file:///`), or obtained using other generic method - and, depending on how it's then handled, may execute in the security context associated with the origin of this data. For example, the following URL:

{{{
jar:http://www.example.com/archive.jar!/resource.html
}}}

...will be retrieved over HTTP from `http://www.example.com/archive.jar`. Because of the encapsulating protocol, the browser will then attempt to interpret the obtained file as a standard Sun Java ZIP archive (`JAR`), and extract, then display `/resource.html` from within that archive, in the context of `example.com`.

Common encapsulating schemes are shown in the table below.

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">feed (RSS, [http://www.brindys.com/winrss/feedformat.html draft spec])</font> || NO || NO || || NO || NO || YES || NO || NO || NO ||
|| <font color="#3050a0">hcp, its, mhtml, mk, ms-help, ms-its, ms-itss (Windows help archive parsing)</font> || YES || YES || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">jar ([http://docs.sun.com/source/819-0913/author/jar.html Java archive parsing])</font> || NO || NO || || YES || YES || NO || NO || NO || NO ||
|| <font color="#3050a0">view-cache, wyciwyg (cached page views)</font> || NO || NO || || YES || YES || NO || NO || YES || NO ||
|| <font color="#3050a0">view-source (page source views)</font> || NO || NO || || YES || YES || NO || NO || YES || NO ||

In addition to encapsulating schemes enumerated above, there are various schemes used for accessing browser-specific internal features unrelated to web content. These pseudo-protocols include `about:` (used to access static info pages, errors, cache statistics, configuration pages, [http://en.wikipedia.org/wiki/About: and more]), `moz-icon:` (used to access file icons), `chrome:`, `chrome-resource:`, `chromewebdata:`, `resource:`, `res:`, `rdf:`, and `inspector:` (all used to reference built-in resources of the browser, often rendered with elevated privileges). There is little or no standardization or proper documentation for these mechanisms, but as a general rule, web content is not permitted to directly reference any sensitive data. Permitting them to go through on trusted pages may serve as an attack vector in case of browser-side vulnerabilities, however.

Finally, several pseudo-schemes exist specifically to enable scripting or URL-contained data rendering in the security context inherited from the caller, without actually referencing any additional external or internal content. It is particularly unsafe to output attacker-controlled URLs of this type on pages that may contain any sensitive content. Known schemes of this type include:

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">data (in-place documents, [http://www.ietf.org/rfc/rfc2397.txt RFC 2397])</font> || NO || NO || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">javascript ([http://developer.mozilla.org/en/docs/JavaScript web scripting])</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">vbscript ([http://msdn.microsoft.com/en-us/library/sx7b3k7y(VS.85).aspx Microsoft proprietary scripting])</font> || YES || YES || || NO || NO || NO || NO || NO || NO ||


_NOTE: Historically, numerous aliases for these schemes were also present; `livescript` and `mocha` schemes were supported by Netscape Navigator and other early browsers as aliases for Javascript; `local` worked in some browsers as a nickname for `file`; etc. This is not witnessed anymore._

==Hypertext Transfer Protocol==

The core protocol used to request and annotate much of web traffic is called the Hypertext Transfer Protocol. This text-based communication method originated as a very simple, underspecified design drafted by Tim Berners-Lee, dubbed HTTP/0.9 ([http://www.w3.org/Protocols/HTTP/AsImplemented.html see W3C archive]) - these days no longer used by web browsers, but recognized by some servers. It then evolved into a fairly complex, and still somewhat underspecified HTTP/1.1, as described in [http://www.ietf.org/rfc/rfc2616.txt RFC 2616], whilst maintaining some superficial compatibility with the original idea.

Every HTTP request opens with a single-line description of a content access method (`GET` meant for requesting basic content, and `POST` meant for submitting state-changing data to servers - along with plethora of more specialized options typically not used by web browsers under normal circumstances). In HTTP/1.0 and up, this is then followed by protocol version specification - and the opening line itself is followed by zero or more additional `field: value` headers, each occupying their own line. These headers specify all sorts of meta-data, from target host name (so that a single machine may host multiple web sites), to information about client-supported MIME types, cache parameters, the site from which a particular request originated (`Referer`), and so forth. Headers are terminated with a single empty line, followed by any optional payload data being sent to the server if specified by a `Content-Length` header. 

One example of an HTTP request might be:

{{{
POST /fuzzy_bunnies/images/bunny_dispenser.php HTTP/1.1
Host: www.fuzzybunnies.com
User-Agent: Bunny Browser 1.7
Content-Type: text/plain
Content-Length: 11
Referer: http://www.fuzzybunnies.com/main.html

HELLO SERVER
}}}

The server responds in a similar manner, returning a numerical status code, spoken protocol version, and similarly formatted metadata headers followed by actual content requested, if available:

{{{
HTTP/1.1 200 OK
Server: Bunny Server 0.9.2
Content-Type: text/plain

HELLO CLIENT
}}}

Originally, every connection would be one-shot: after a request is sent, and response received, the session is terminated, and a new connection needs to be established. Since the need to carry out a complete TCP/IP handshake for every request imposed a performance penalty, newer specifications introduced the concept of keep-alive connections, negotiated with a particular request header that is then acknowledged by the server.

This, in conjunction with the fact that HTTP supports proxying and content caching on interim systems managed by content providers, ISPs, and individual subscribers, made it particularly important for all parties involved in an HTTP transaction to have exactly the same idea of where a request starts, where it ends, and what it is related to. Unfortunately, the protocol itself is highly ambiguous and has a potential for redundancy, which leads to multiple problems and differences between how servers, clients, and proxies may interpret responses:

  * Like many other text protocols of that time, early takes on HTTP made little or no effort to mandate a strict adherence to a particular understanding of what a text-based format really is, or how certain "intuitive" field values must be structured. Because of this, implementations would recognize, and often handle in incompatible ways, technically malformed inputs - such as incorrect newline characters (lone `CR`, lone `LF`, `LF CR`), `NUL` or other disruptive control characters in text, incorrect number of whitespaces in field delimiters, and so forth; to various implementations, `Head\0er: Value` may appear as `Head`, `Head: Value`, `Header: Value`, or `Head\0er: Value`. In later versions, as outlined in RFC 2616 section 19.3 ("Tolerant Applications"), the standard explicitly recommends, but does not require, lax parsing of certain fields and invalid values. One of the most striking examples of compatibility kludges is Firefox [http://mxr.mozilla.org/mozilla1.8.0/source/nsprpub/pr/src/misc/prtime.c#1045 prtime.c] function used to parse HTTP `Date` fields, which shows a stunning complexity behind what should be a remarkably simple task.

  * No particular high bit character set is defined for HTTP headers, and high bit characters are technically disallowed, despite legitimate reasons for them to appear in certain HTTP fields (e.g., `Cookie`, `Content-Disposition` filenames), and the protocol having no provisions for any particular method of escaping them. This resulted in some implementations interpreting HTTP data as UTF-8, and some using single-byte interpretations native to low-level OS string handling facilities.

   * The behavior when some headers critical to the correct understanding of an HTTP request are duplicate or contradictory is not well defined; as such, various clients will give precedence to different occurrences of the same parameter within HTTP headers (e.g., duplicate `Content-Type`), or assign various weights to conflicting information (say, `Content-Length` not matching payload length).

   * When new features that change the meaning of requests were introduced in HTTP/1.1 standard, no strict prohibition against recognizing them in requests or responses marked as HTTP/1.0 was made. As a result, the understanding of HTTP/1.0 traffic may differ significantly between legacy agents, such as some commercial web proxies, and HTTP/1.1 applications such as contemporary browsers (e.g., `Connection: keep-alive`, `Transfer-Encoding: chunked`, `Accept-Encoding: ...`).

Many specific areas, such as caching behavior, have their own sections later in this document. Below is a survey of general security-relevant differences in HTTP protocol implementations:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">`Content-Length` header value overrides actual content length?</font> || NO || YES || || NO || NO || YES || YES || NO || YES ||
|| <font color="#3050a0">First HTTP header of the same name takes precedence?</font> || YES || YES || || NO || NO || YES || NO || NO || NO ||
|| <font color="#3050a0">First field value in a HTTP header takes precedence?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">`Referer` header sent on HTTPS → HTTPS navigation?</font> || YES || YES || || YES || YES || YES || <font color="#30ff30">NO</font> || YES || YES ||
|| <font color="#3050a0">`Referer` header sent on HTTPS → HTTP navigation?</font> || NO || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Response body on invalid 30x redirect shown to user?</font> || NO || NO || || YES || YES || NO || YES || YES || NO ||

==Hypertext Markup Language==

Hypertext Markup Language, the primary document format rendered by modern web browsers, has its roots with [http://en.wikipedia.org/wiki/SGML Standard Generalized Markup Language], a standard for machine-readable documents. The initial [http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html HTML draft] provided a very limited syntax intended strictly to define various functional parts of the document. With the rapid development of web browsers, this basic technology got extended very rapidly and with little oversight to provide additional features related to visual presentation, scripting, and various perplexing and proprietary bells and whistles. Perhaps more interestingly, the format was also extended to provide the ability to embed other, non-HTTP multimedia content on pages, nest HTML documents within frames, and submit complex data structures and client-supplied files.

The mess eventually led to a post-factum compromise standard dubbed [http://www.w3.org/TR/REC-html32 HTML 3.2]. The outcome of this explosive growth was a format needlessly hard to parse, and combining unique quirks, weird limitations, and deeply intertwined visual style and document structure information - and so ever since, W3C and WHATWG focused on making HTML a clean, strict, and well-defined language, a goal at least approximated with [http://www.w3.org/TR/html401/ HTML 4] and [http://www.w3.org/TR/xhtml2/ XHTML] (a variant of HTML that strictly conforms to XML syntax rules), as well as the ongoing work on [http://www.w3.org/TR/html5/ HTML 5].

This day, the four prevailing HTML document rendering implementations are:

  * [http://msdn.microsoft.com/en-us/library/aa741317.aspx Trident] (MSHTML) - used in MSIE6, MSIE7, MSIE8,
  * [http://developer.mozilla.org/en/Gecko Gecko] - used in Firefox and derivates,
  * [http://webkit.org/ WebKit] - used by Safari, Chrome, Android,
  * Presto - used in Opera.

The ability for various applications to accurately understand HTML document structure, as it would be seen by a browser, is an important security challenge. The serial nature of the HTML blends together code (Javascript, Flash, Java applets) and the actual data to be displayed - making it easy for attackers to smuggle dangerous directives along with useful layout information in any external content. Knowing exactly what is being rendered is often crucial to site security (see [http://code.google.com/p/doctype/wiki/ArticleXSS this article] for a broader discussion of the threat).

Sadly, for compatibility reasons, parsers operating in non-XML mode tend are generally lax and feature proprietary, incompatible, poorly documented recovery modes that make it very difficult for any platform to anticipate how a third-party HTML document would be interpreted. Any of the following grossly malformed examples may be interpreted as a scripting directive by some, but usually not all, renderers:

{{{
1: <B <SCRIPT>alert(1)</SCRIPT>>
2: <B="<SCRIPT>alert(1)</SCRIPT>">
3: <IMG SRC=`javascript:alert(1)`>
4: <S[0x00]CRIPT>alert(1)</S[0x00]CRIPT>
5: <A """><IMG SRC="javascript:alert(1)">
6: <IMG onmouseover =alert(1)>
7: <A/HREF="javascript:alert(1)">
8: <!-- Hello -- world > <SCRIPT>alert(1)</SCRIPT> -->
}}}

Cross-site scripting aside, another interesting property of HTML is that it permits certain HTTP directives to be encoded within HTML itself, using the following format:

{{{
<META HTTP-EQUIV="Content-Type" VALUE="text/html; charset=utf-8">
}}}

Not all `HTTP-EQUIV` directives are meaningful - for example, the determination of `Content-Type`, `Content-Length`, `Location`, or `Content-Disposition` had already been made by the time HTML parsing begins - but some values seen may be set this way. The strategy for resolving HTTP - HTML conflicts is not outlined in W3C standards - but in practice, valid HTTP headers take precedence over `HTTP-EQUIV`; on the other hand, `HTTP-EQUIV` takes precedence over unrecognized HTTP header values. `HTTP-EQUIV` tags will also take precedence when the content is moved to non-HTTP media, such as saved to local disk.

Key security-relevant differences between HTML parsing modes in the aforementioned engines are shown below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Parser resets on nested HTML tags (`<FOO <BAR...`)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Recursive recovery with nested tags (both `FOO` and `BAR` interpreted)?</font> || (NO) || (NO) || || YES || YES || YES || NO || YES || YES ||
|| <font color="#3050a0">Parser resets out on invalid tag names (`<FOO="<BAR...`)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Trace-back recovery on missing tag closure (`<FOO BAR="<BAZ(EOF)`)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || NO ||
|| <font color="#3050a0">SGML-style comment parsing permitted in strict mode (`--` and `>` may appear separately)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || NO ||
|| <font color="#3050a0">!-type tags are parsed in a non-HTML manner (`<!FOO BAR="-->"...` breaks)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || NO ||
|| <font color="#3050a0">Characters accepted as tag name / parameter separators (excluding `\t \r \n \x20`)</font> || \x0B \x0C <font color="#ff0000">/</font> || \x0B \x0C <font color="#ff0000">/</font> || || <font color="#ff0000">/</font> || <font color="#ff0000">/</font> || \x0B \x0C || \x0B \x0C \xA0 || \x0B \x0C || \x0B \x0C ||
|| <font color="#3050a0">Characters ignored between parameter name, equals sign, and value (excluding `\t \r \n`)</font> || \x0B \x0C \x20 || \x0B \x0C \x20 || || \x20 || \x20 || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> || \x20 \xA0 || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> ||
|| <font color="#3050a0">Characters accepted in lieu of quotes for HTML parameters (excluding `"`)</font> || ' <font color="#ff0000">`</font> || ' <font color="#ff0000">`</font> || || ' || ' || ' || ' || ' || ' || 
|| <font color="#3050a0">Characters accepted in tag names (excluding `A-Z / ? !`)</font> || <font color="#ff0000">\0 %*</font>|| <font color="#ff0000">\0 %</font> || || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#ff0000">\0</font> || <font color="#909090">none</font> || <font color="#909090">none</font> ||

<b></b>

===HTML entity encoding===

HTML features a special encoding scheme called [http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references HTML entities]. The purpose of this scheme is to make it possible to safely render certain reserved HTML characters (e.g., `< > &`) within documents, as well as to carry high bit characters safely over 7-bit media. The scheme nominally permits three types of notation:

  * One of predefined, named entities, in the format of `&<name>;` - for example `&lt;` for `<`, `&gt;` for `>`, `&rarr;` for `→`, etc,

  * Decimal entities, `&#<nn>;`, with a number corresponding to the desired Unicode character value - for example `&#60;` for `<`, `&#8594;` for `→`,

  * Hexadecimal entities, `&#x<nn>;`, likewise - for example `&#x3c;` for `<`, `&#x2192;` for `→`.

In every browser, HTML entities are decoded only in parameter values and stray text between tags. Entities have no effect on how the general structure of a document is understood, and no special meaning in sections such as `<SCRIPT>`. The ability to understand and parse the syntax is still critical to properly understanding the value of a particular HTML parameter, however. For example, as hinted in one of the earlier sections, `<A HREF="javascript&#09;:alert(1)">` may need to be parsed as an absolute reference to `javascript<TAB>:alert(1)`, as opposed to a link to something called `javascript&` with a local URL hash string part of `#09;alert(1)`.

Unfortunately, various browsers follow different parsing rules to these HTML entity notations; all rendering engines recognize entities with no proper `;` terminator, and all permit entities with excessively long, zero-padded notation, but with various thresholds:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Maximum length of a correctly terminated decimal entity</font> || <font color="#ff0000">7</font> || <font color="#ff0000">7</font> || || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">∞</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">8</font>^*^ ||
|| <font color="#3050a0">Maximum length of an incorrectly terminated decimal entity</font> || <font color="#ff0000">7</font> || <font color="#ff0000">7</font> || || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">∞</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">8</font>^*^ ||
|| <font color="#3050a0">Maximum length of a correctly terminated hex entity</font> || <font color="#ff0000">6</font> || <font color="#ff0000">6</font> || || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">∞</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">8</font>^*^ ||
|| <font color="#3050a0">Maximum length of an incorrectly terminated hex entity</font> || 0 || 0 || || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">∞</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">8</font>^*^ ||
|| <font color="#3050a0">Characters permitted in entity names]] (excluding `A-Z a-z 0-9`)</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || || <font color="#ff0000">- . _</font> || <font color="#ff0000">- . _</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#909090">none</font> ||

^*^ Entries one byte longer than this limit still get parsed, but incorrectly; for example, `&#000000065;` becomes a sequence of three characters, `\x06 5 ;`. Two characters and more do not get parsed at all - `&#0000000065;` is displayed literally).

An interesting piece of trivia is that, as per HTML entity encoding requirements, links such as:

{{{
http://example.com/?p1=v1&p2=v2
}}}

Should be technically always encoded in HTML parameters (but not in Javascript code) as:

{{{
<a href="http://example.com/?p1=v1&amp;p2=v2">Click here</a>
}}}

In practice, however, the convention is almost never followed by web developers, and browsers compensate for it by treating invalid HTML entities as literal `&`-containing strings.

==Document Object Model==

As the web matured and the concept of client-side programming gained traction, the need arose for HTML document to be programatically accessible and modifiable on the fly in response to user actions. One technology, [http://www.w3.org/DOM/DOMTR Document Object Model] (also referred to as "dynamic HTML"), emerged as the prevailing method for accomplishing this task.

In the context of web browsers, Document Object Model is simply an object-based representation of HTML document layout, and by a natural extension much of the browser internals, in a hierarchical structure with various read and write properties, and callable methods. To illustrate, to access the value of the first `<INPUT>` tag in a document through DOM, the following Javascript code could be used:

{{{
document.getElementsByTagName('INPUT')[0].value
}}}

Document Object Model also permits third-party documents to be referenced, subject to certain security checks discussed [#Same-origin_policy_for_DOM_access later on]; for example, the following code accesses the `<INPUT>` tag in the second `<IFRAME>` on a current page:

{{{
document.getElementsByTagName('IFRAME')[1].contentDocument.getElementsByTagName('INPUT')[0].value
}}}

DOM object hierarchy - as seen by programmers - begins with an implicit "root" object, sometimes named `defaultView` or `global`; all the scripts running on a page have `defaultView` as their default scope. This root object has the following members:

  * Various properties and methods relating to current document-specific window or frame ([http://www.w3schools.com/HTMLDOM/dom_obj_window.asp reference]). Properties include window dimensions, status bar text, references to parent, top-level, and owner (opener) `defaultView` objects. Methods permit scripts to resize, move, change focus, or decor of current windows, display certain UI widgets, or - oddly enough - set up Javascript timers to execute code after a certain "idle" interval.

  * All the current script's global variables and functions.

  * `defaultView.document` ([http://www.w3schools.com/HTMLDOM/dom_obj_document.asp reference]) - a top-level object for the actual, proper _document_ object model. This hierarchy represents all of the document elements, along with their specific methods and properties, and document-wide object lookup functions (e.g., `getElementById`, `getElementsByTagName`, etc).

  * `defaultView.location` ([http://www.w3schools.com/HTMLDOM/dom_obj_location.asp reference]) - a simple object describing document's current location, both as an unparsed string, and split into parsed segments; provides methods and property setters that allow scripts to navigate away to other sites.

  * `defaultView.history` ([http://www.w3schools.com/HTMLDOM/dom_obj_history.asp reference]) - another simple object offering three methods to enable pages to navigate back to previously visited pages.

  * `defaultView.screen` ([http://www.w3schools.com/HTMLDOM/dom_obj_screen.asp reference]) - yet another modestly sized object with a bunch of mostly read-only properties describing properties of the current display device, including pixel and DPI resolution, and so forth.

  * `defaultView.navigator` ([http://www.w3schools.com/HTMLDOM/dom_obj_navigator.asp reference]) - an object containing read-only properties such as browser make and version, operating platform, or plugin configuration.

  * `defaultView.window` - a self-referential entry that points back to the root object; this is the name by which the `defaultView` object is most commonly known. In general, `screen`, `navigator`, and `window` DOM hierarchies combined usually contain enough information to very accurately fingerprint any given machine.

With the exception of cross-domain, cross-document access permissions outlined in later chapters, the operation of DOM bears relatively little significance to site security. It is, however, worth noting that DOM methods are wrappers providing access to highly implementation-specific internal data structures that may or may not obey the usual rules of Javascript language. Because of this, multiple seemingly inexplicable oddities and quirks plague DOM data structures in every browsers - and some of these may interfere with client-side security mechanisms. Several such quirks are documented below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is `window` the same object as `window.window`?</font> || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is `document.URL` writable?</font> || NO || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Can builtin DOM objects be clobbered?</font> || shadowing || shadowing || || shadowing || shadowing || shadowing || shadowing || shadowing || shadowing ||

_Trivia: traversing `document.*` is a possible approach to look up specific input or output fields when modifying complex pages from within scripts, but it is not a very practical one; because of this, most scripts resort to `document.getElementById()` method to uniquely identify elements regardless of their current location on the page. Although `ID=` parameters for tags within HTML documents are expected to be unique, there is no such guarantee. Currently, all major browsers seem to give the first occurrence a priority._

==Browser-side Javascript==

[http://en.wikipedia.org/wiki/Javascript Javascript] is a relatively simple but rich, object-based imperative scripting language tightly integrated with HTML, and supported by all contemporary web browsers. Authors claim that the language has roots with [http://en.wikipedia.org/wiki/Scheme_(programming_language) Scheme] and [http://en.wikipedia.org/wiki/Self_(programming_language) Self] programming languages, although it is often characterized in a more down-to-earth way as resembling a crossover of [http://en.wikipedia.org/wiki/Objective-C Objective C] and [http://en.wikipedia.org/wiki/Visual_Basic Visual Basic]. Confusingly, except for the common C syntax, it shares relatively few unique features with [http://en.wikipedia.org/wiki/Java_(programming_language) Java]; the naming is simply a marketing gimmick devised by Netscape and Sun in the 90s.

The language is a creation of Netscape engineers, originally marketed under the name of Mocha, then Livescript, and finally rebranded to Javascript; Microsoft embraced the concept shortly thereafter, under the name of JScript. The language, as usual with web technologies, got standardized only post factum, under a yet another name - ECMAScript. Additional, sometimes overlapping efforts to bring new features and extensions of the language - for example, [http://wiki.ecmascript.org/doku.php ECMAScript 4], [http://developer.mozilla.org/Special:Tags?tag=JavaScript_version_overviews&language=en Javascript versions 1.6-1.8], [http://developer.mozilla.org/En/E4X native XML objects], etc - are taking place, although none of these concepts managed to win broad acceptance and following.

Browser-side Javascript is invoked from within HTML documents in four primary ways: 

  # Standalone `<SCRIPT>` tags that enclose code blocks,<p />
  # Event handlers tied to HTML tags (e.g. `onmouseover="..."`),<p />
  # Stylesheet `expression(...)` blocks that permit Javascript syntax in some browsers,<p />
  # Special URL schemes specified as targets for certain resources or actions (`javascript:...`),

Note that the first option does not always work when such a string is dynamically added by running Javascript to an existing document. That said, any of the remaining options might be used as a comparable substitute.

Regardless of their source (`<SCRIPT SRC="...">`), remote scripts always execute in the security context of the document they are attached to. Once called, Javascript has full access to the current DOM, and limited access to DOMs of other windows; it may also further invoke new Javascript by calling `eval()`, configuring timers (`setTimeout(...)` and `setInterval(...)`), or producing Javascript-invoking HTML. Javascript may also configure self to launch when its objects are interacted with by third-party Javascript code, by configuring watches, setters, or getters, or cross contexts by calling same-origin functions belonging to other documents.

Javascript enjoys very limited input and output capabilities. Interacting with same-origin document data and drawing [http://developer.mozilla.org/en/Canvas_tutorial CANVASes], displaying `window.*` pop-up dialogs, and writing script console errors aside, there are relatively few I/O facilities available. File operations or access to other persistent storage is generally not possible, although some [https://developer.mozilla.org/en/DOM/Storage experimental features] are being introduced and quickly scraped. Scripts may send and receive data from the originating server using the [http://www.w3.org/TR/XMLHttpRequest/ XMLHttpRequest] extension, which permits scripts to send and read arbitrary payloads; and may also automatically send requests and read back properly formatted responses by issuing `<SCRIPT SRC="...">`, or `<LINK REL="Stylesheet" HREF="...">`, even across domains. Lastly, Javascript may send information to third-party servers by spawning objects such as `<IMG>`, `<IFRAME>`, `<OBJECT>`, `<APPLET>`, or by triggering page transitions, and encoding information in the URL that would be automatically requested by the browser immediately thereafter - but it may not read back the returned data. Some side channels related to browser caching mechanisms and lax DOM security checks also exist, providing additional side channels between cooperating parties.

Some of the other security-relevant characteristics of Javascript environments in modern browsers include:

  * *Dynamic, runtime code interpretation with no strict code caching rules*. Any code snippets located in-line with HTML tags would be interpreted and executed, and Javascript itself has a possibility to either directly evaluate strings as Javascript code (`eval(...)`), or to produce new HTML that in turn may contain more Javascript (`.innerHTML` and `.outerHTML` properties, `document.write()`, event handlers). The behavior of code that attempts to modify own container while executing (through DOM) is not well-defined, and varies between browsers.

  * *Somewhat inconsistent exception support*. Although within the language itself, exception-throwing conditions are well defined, it is not so when interacting with DOM structures. Depending on the circumstances, some DOM operations may fail silently (with writes or reads ignored), return various magic responses (`undefined`, `null`, `object inaccessible`), throw a non-standardized exception, or even abort execution unconditionally.

  * *Somewhat inconsistent, but modifiable builtins and prototypes*. The behavior of many language constructs might be redefined by programs within the current context by modifying object setters, getters, or overwriting prototypes. Because of this, reliance on any specific code - for example a security check - executing in a predictable manner in the vicinity of a potentially malicious payload is risky. Notably, however, not all builtin objects may be trivially tampered with - for example, `Array` prototype setters may be modifiable, but `XML` not so. There is no fully-fledged operator overloading in Javascript 1.x.

  * *Typically synchronous execution*. Within a single document, browser-side Javascript usually executes synchronously and in a single thread, and asynchronous timer events are not permitted to fire until the scripting engine enters idle state. No strict guarantees of synchronous execution exist, however, and multi-process rendering of Chrome or MSIE8 may permit cross-domain access to occur more asynchronously.

  * *Global function lookups not dependent on ordering or execution flow*. Functions may be invoked in a block of code before they are defined, and are indexed in a pass prior to execution. Because of this, reliance on top-level no-return statements such as `while (1);` to prevent subsequent code from being interpreted might be risky.

  * *Endless loops that terminate*. As a security feature, when the script executes for too long, the user is prompted to abort execution. This merely causes current execution to be stopped, but does not prevent scripts from being re-entered.

  * *Broad, quickly evolving syntax*. For example, E4X extensions in Firefox [http://code.google.com/p/doctype/wiki/ArticleE4XSecurity well-structured XHTML or XML to be interpreted] as a Javascript object, also executing any nested Javascript initializers within such a block. This makes it very difficult to assume that a particular format of data would not constitute valid Javascript syntax in a future-proof manner.

Inline script blocks embedded within HTML are somewhat tricky to sanitize if permitted to contain user-controlled strings, because, much like `<TEXTAREA>`, `<STYLE>`, and several other HTML tags, they follow a counterintuitive CDATA-style parsing: a literal sequence of `</SCRIPT>` ends the script block regardless of its location within the Javascript syntax as such. For example, the following code block would be ended prematurely, and lead to unauthorized, additional Javascript block being executed:

{{{
<SCRIPT>
var user_string = 'Hello world</SCRIPT><SCRIPT>alert(1)</SCRIPT>';
</SCRIPT>
}}}

Various differences between browser implementations are outlined below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is setter and getter support present?</font> || NO || NO || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is access to prototypes via `__proto__` possible?</font> || NO || NO || || YES || YES || YES || NO || YES || YES ||
|| <font color="#3050a0">Is it possible to alias `eval()` function? || YES || YES || || PARTLY || PARTLY || YES || PARTLY || NO || YES ||
|| <font color="#3050a0">Are watches on objects supported?</font> || NO || NO || || YES || YES || NO || NO || NO || NO ||
|| <font color="#3050a0">May currently executing code blocks modify self?</font> || read-only || read-only || || NO || NO || NO || YES || NO || NO ||
|| <font color="#3050a0">Is E4X extension supported?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || NO ||
|| <font color="#3050a0">Is `charset=` honored on `<SCRIPT SRC="...">`?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||

<b></b>

===Javascript character encoding===

To permit handling of strings that otherwise contain restricted literal text (such as `</SCRIPT>`, `"`, `'`, `CL` or `LF`, other non-printable characters), Javascript offers five character encoding strategies:

  # Three-digit, zero-padded, 8-bit octal numerical representations, C-style (`"test"` →  `"t\145st"`),<p />
  # Two-digit, zero-padded, 8-bit hexadecimal numerical representations, with C-style `\x` prefix (`"test"` → `"t\x65st"`),<p />
  # Four-digit, zero-padded, 16-bit hexadecimal numerical Unicode representations, with `\u` prefix (`"test"` → `"t\u0065st"`),<p />
  # Raw `\` prefix before a literal (`"test"` → `"t\est"`),<p />
  # Special C-style `\` shorthand notation for certain control characters (such as `\n` or `\t`).

The fourth scheme is most space-efficient, although generally error-prone; for example, a failure to escape `\` as `\\` may lead to a string of `\" + alert(1);"` being converted to `\\" + alert(1)`, and getting interpreted incorrectly; it also partly collides with the remaining `\`-prefixed escaping schemes, and is not compatible with C syntax.

The parsing of these schemes is uniform across all browsers if fewer than the expected number of input digits is seen: the value is interpreted correctly, and no subsequent text is consumed (`"\1test"` is accepted and becomes `"\001test"`).

HTML entity encoding has no special meaning within HTML-embedded `<SCRIPT>` blocks. 

Amusingly, although all the four aforementioned schemes are supported in Javascript proper, a proposed informational standard for Javascript Object Notation (JSON), a transport-oriented serialization scheme for Javascript objects and arrays ([http://www.ietf.org/rfc/rfc4627.txt RFC 4627]), technically permits only the `\u` notation and a seemingly arbitrary subset of `\` control character shorthand codes (options 3 and 5 on the list above). In practice, since JSON objects are almost always simply passed to `eval(...)` in client-side Javascript code to convert them back to native data structures, the limitation is not enforced in a vast majority of uses. Because of the advice provided in the RFC, some non-native `parseJSON` implementations (such as the [http://json.org/json2.js current example reference implementation] from [http://json.org json.org]) may not handle traditional `\x` escape codes properly, however. It is also not certain what approach would be followed by browsers in the currently discussed [http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2008-June/015078.html native, non-executing parsers] proposed for performance and security reasons.

Unlike in some C implementations, stray multi-line string literals are not permitted by Javascript, but lone `\` at the end of a line may be used to break long lines in a seamless manner.

==Other document scripting languages==

[http://msdn.microsoft.com/en-us/library/sx7b3k7y(VS.85).aspx VBScript] is a language envisioned by Microsoft as a general-purpose "hosted" scripting environment, incorporated within Windows as such, Microsoft IIS, and supported by Microsoft Internet Explorer via `vbscript:` URL scheme, and through `<SCRIPT>` tags. As far as client-side scripting is considered, the language did not seem to offer any significant advantages over the competing Javascript technology, and lagged in several areas.

Presumably because of this, the technology never won any browser support outside MSIE (with all current versions supporting it), and is very seldom relied upon. Where permitted to go through, however, it has roughly the same security consequences as Javascript. The attack surface and security controls within VBScript are poorly studied in comparison to Javascript, however.

==Cascading stylesheets==

As the initial HTML designs evolved to include a growing body of eye candy, the language ended up mixing very specific visual presentation cues with content classification directives; for example, a similar inline syntax would denote that the following piece of text is an element of a numbered list, or that it needs to be shown in 72 pt <font face="Comic Sans MS">Comic Sans</font> font. This notation, although convenient to use on new pages, made it very difficult to automatically adjust appearance of a document without altering its structure (for example to account for mobile devices, printable views, or accessibility requirements), or to accurately preserve document structure when moving the data to non-HTML media or new site layouts.

[http://www.w3.org/Style/CSS/ Cascading Style Sheets] is a simple concept that corrects this problem, and also provides a much more uniform and featured set of tools to alter the visual appearance of any portion of the document, far surpassing the original set of kludgy HTML tag attributes. A stylesheet outlines visual rendering rules for various functional types of document elements, such as lists, tables, links, or quotations, using a separate block of data with a relatively simple syntax. Although the idea of style sheets as such predates HTML, the current design used for the web stabilized in the form of W3C proposals only around 1998 - and because of the complex changes required to renderers, it took several years for reasonably robust implementations to become widespread. 

There are three distinct ways to place CSS directives in HTML documents: 

  # The use of an inline `STYLE="..."` parameter attached to HTML tags of any type; attributes specified this way apply to this and nested tags only (and largely defeat the purpose of the entire scheme when it comes to making it easy to alter the appearance of a document),<p />
  # Introduction of a block of CSS code with `<STYLE>...</STYLE>` in any portion of the document. This block may change the default appearance of any tag, or define named rulesets that may be explicitly applied to specific tags with a `CLASS="..."` parameter,<p />
  # Inclusion of a remote stylesheet with a <`LINK REL="stylesheet" HREF="...">`, with the same global effect as a `<STYLE>` block.

Because CSS provides a powerful and standardized method to control the visual appearance of a block of HTML, many applications strive to let third parties control a subset of CSS syntax emitted in documents. Unfortunately, the task is fairly tricky; the most important security consequences of attacker-controlled stylesheets are:

  * *The risk of Javascript execution*. As a little-known feature, some CSS implementations permit Javascript code to be embedded in stylesheets. There are at least three ways to achieve this goal: by using the `expression(...)` directive, which gives the ability to evaluate arbitrary Javascript statements and use their value as a CSS parameter; by using the `url('javascript:...')` directive on properties that support it; or by invoking browser-specific features such as the [http://www.securiteam.com/securitynews/5LP051FHPE.html -moz-binding] mechanism of Firefox.

  * *The ability to freely position text*. If user-controlled stylesheets are permitted on a page, various powerful CSS positioning directives may be invoked to move text outside the bounds of its current container, and mimick trusted UI elements or approximate them very accurately. Some examples of absolute positioning directives include `z-index`, `margin`, `padding`, `bottom`, `left`, `position`, `right`, `top`, or `text-indent` (many of them with sub-variants, such as `margin-left`).

  * *The ability to reuse trusted classes*. If user-controlled `CLASS="..."` attributes are permitted in HTML syntax, the attacker may have luck "borrowing" a class used to render elements of the trusted UI and impersonate them.

Much like Javascript, stylesheets are also tricky to sanitize, because they follow CDATA-style parsing: a literal sequence of `</STYLE>` ends the stylesheet regardless of its location within the CSS syntax as such. For example, the following stylesheet would be ended prematurely, and lead to Javascript code being executed:

{{{
<STYLE>
body {
  background-image: url('http://example.com/foo.jpg?</STYLE><SCRIPT>alert(1)</SCRIPT>');
}
</STYLE>
}}}

Another interesting property specific to `<STYLE>` handling is that when two CDATA-like types overlap, no particular outcome is guaranteed; for example, the following may be interpreted as a script, or as an empty stylesheet, depending on the browser:

{{{
<STYLE>
<!-- </STYLE><SCRIPT>alert(1)</SCRIPT> -->
</STYLE>
}}}

Various differences in style parsing between common browsers are outlined below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is Javascript `expression(...)` supported?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is script-targeted `url(...)` supported?</font> || <font color="#ff0000">YES</font> || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is script-executing `-moz-binding` supported?</font> || NO || NO || || <font color="#ff0000">YES</font> || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Does `</STYLE>` take precedence over comment block parsing?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || NO ||
|| <font color="#3050a0">Characters permitted as CSS field-value separators (excluding `\t \r \n \x20`)</font> || \x0B \x0C \ \xA0 || \x0B \x0C \ \xA0 || || \x0B \x0C \ || \x0C \ || \x0C \ || \x0C \ \xA0 || \x0C \ \xA0 || \x0C \ ||

<b></b>

===CSS character encoding===

In many cases, as with Javascript, there is a need for web applications to render certain user-supplied user-controlled strings within stylesheets in a safe manner. To handle various reserved characters, a method for escaping potentially troublesome values is required; confusingly, however, CSS format supports neither HTML entity encoding, nor any of the common methods of encoding characters seen in Javascript. 

Instead, a rather unusual and incompatible scheme consisting of `\` followed by non-prefixed, two-digit, zero-padded, 8-bit hexadecimal is employed; for example, `"test"` may be encoded as `"t\65st"` - but not as `t\est"`, `"t\x65st"`, `"t\u0065st"`, nor `"t&#x65;st"`.

Like in Javascript, stray multi-line string literals are not supported, but a lone `\` at the end of a line may be used to seamlessly break long lines; and overly short escape sequences are parsed correctly, without consuming any of the following text (`"\1test"` → `"\01test"`).

==Other built-in document formats==

HTML aside, modern browser renderers usually natively support an additional set of media formats that may be displayed as standalone documents. These can be generally divided into two groups:

  * *Pure data formats.* These include plain text data or images (JPEG, GIF, BMP, etc), where the browser simply provides a basic rendering canvas and populates it with static data. In principle, no security consequences arise with these data types, as no malicious payloads may be embedded in the message - short of major and fairly rare implementation flaws. Common image formats aside, some browsers may also support other oddball or legacy media formats natively, such as the ability to play [http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface MID] files specified by `<BGSOUND>` tags.

  * *Rich data formats.* This category is primarily populated by non-HTML XML namespace parsers ([http://www.w3.org/Graphics/SVG/ SVG], [http://www.rssboard.org/rss-specification RSS], [http://tools.ietf.org/html/rfc4287 Atom]); beyond raw data, these document formats contain various rendering instructions, hints, or conditionals. Because of how XML works, each of the XML-based formats has two important security consequences:<p />
    * Firstly, nested XML namespaces may be defined, and are usually not verified against MIME type intents, permitting HTML to be embedded for example inside `image/svg+xml`.<p />
    * Secondly, these formats may actually come with provisions for non-standard embedded HTML payloads or scripts built in, permitting HTML injection even if the attacker has no direct control over XML document structure.

One example of a document that, even if served as `image/svg+xml`, would still execute scripts in many current browsers despite MIME type clearly stating a different intent, is as follows:

{{{
<?xml version="1.0"?>
<container>
  <svg xmlns="http://www.w3.org/2000/svg">
    [...]
  </svg>
  <html xmlns="http://www.w3.org/1999/xhtml">
    <script>alert('Hello world!')</script>
  </html>
</container>
}}}

Some of the non-HTML builtin document type behaviors are documented below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Supported image formats (excluding JPG, GIF, PNG)</font> || BMP ICO || BMP ICO || || BMP ICO TGA || BMP ICO TGA || BMP TIF || <font color="#909090">none</font> || BMP ICO || BMP ICO ||
|| <font color="#3050a0">Is generic XML document support present?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is RSS feed support present?</font> || NO || YES || || YES || YES || YES || YES || NO || NO ||
|| <font color="#3050a0">Is ATOM feed support present</font> || NO || YES || || YES || YES || YES || YES || NO || NO ||
|| <font color="#3050a0">Does Javascript execute within feeds?</font> || <font color="#ff0000">(YES)</font> || NO || || NO || NO || NO || NO || <font color="#ff0000">(YES)</font> || <font color="#ff0000">(YES)</font> ||
|| <font color="#3050a0">Are `javascript:` or `data:` URLs permitted in feeds?</font> || <font color="#909090">n/a</font> || NO || || NO || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Are CSS specifications permitted in feeds?</font> || <font color="#909090">n/a</font> || NO || || YES || YES || NO || YES || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Is SVG image support present?</font> || NO || NO || || YES || YES || YES || YES || YES || NO ||
|| <font color="#3050a0">May `image/svg+xml` document contain HTML `xmlns` payload?</font> || <font color="#ff0000">(YES)</font> || <font color="#ff0000">(YES)</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">(YES)</font> ||

_Trivia: curiously, Microsoft's XML-based [http://www.w3.org/TR/NOTE-VML.html Vector Markup Language] (VML) is not natively supported by the renderer, and rather implemented as a plugin; whereas Scalable Vector Graphics (SVG) is implemented as a core renderer component in all browsers that support it._

==Plugin-supported content==

Unlike the lean and well-defined set of natively supported document formats, the landscape of browser plugins is extremely diverse, hairy, and evolving very quickly. Most of the common content-rendering plugins are invoked through the use of `<OBJECT>` or `<EMBED>` tags (or `<APPLET>`, for Java), but other types of integration may obviously take place. 

Common document-embeddable plugins can be generally divided into several primary categories:

  * *Web programming languages*. This includes technologies such as [http://en.wikipedia.org/wiki/Adobe_Flash Adobe Flash], [http://en.wikipedia.org/wiki/Java_programming_language multi-vendor Java], or [http://en.wikipedia.org/wiki/Silverlight Microsoft Silverlight], together present at a vast majority of desktop computers. These languages generally permit extensive scripting, including access to the top-level document and other DOM information, or the ability to send network requests to at least some locations. The security models implemented by these plugins generally diverge from the models of the browser itself in sometimes counterintuitive or underspecified ways (discussed in more detail [#Same-origin_policy_for_Flash later on]).<p />This property makes such web development technologies a major attack surface by themselves if used legitimately. It also creates a security risk whenever a desire to user content arises, as extra steps must be taken to make sure the data could never be accidentally interpreted as a valid input to any of the popular plugins.

  * *Drop-in integration for non-HTML document formats*. Some popular document editors or viewers, including [http://en.wikipedia.org/wiki/Adobe_Acrobat Acrobat Reader] and [http://en.wikipedia.org/wiki/Microsoft_Office Microsoft Office], add the ability to embed their supported document formats as objects on HTML pages, or to view content, full-window, directly within the browser. The interesting property of this mechanism is that many such document formats either feature scripting capabilities, or offer interactive features (e.g., clickable links) that may result in data passed back to the browser in unusual ways. This property makes such document formats roughly equivalent to programming language engines proper.

  * *Specialized HTML-integrated markup languages*. In addition to kludgy drop-in integration for document formats very different from HTML, specialized markup languages such as [http://en.wikipedia.org/wiki/VRML VRML], [http://www.w3.org/TR/NOTE-VML.html VML], or [http://en.wikipedia.org/wiki/MathML MathML], are also supported in some browsers through plugins, and meant to discretely supplement regular HTML documents; these may enable HTML smuggling vectors similar to those of renderer-handled XML formats (see previous section).

  * *Rich multimedia formats*. A variety of plugins brings the ability to play video and audio clips directly within the browser, without opening a new media player window. Plugin-driven browser integration is offered by almost all contemporary media players, including [http://en.wikipedia.org/wiki/Windows_Media_Player Windows Media Player], [http://en.wikipedia.org/wiki/QuickTime QuickTime], [http://en.wikipedia.org/wiki/RealPlayer RealPlayer], or [http://en.wikipedia.org/wiki/VLC VLC], again making it a widely available capability. Most of such formats bear no immediate security consequences for the hosting party per se, although in practice, this type of integration is plagued by implementation-specific bugs.

  * *Specialized data manipulation widgets*. This includes features such as DHTML ActiveX editing gizmos (`2D360201-FFF5-11D1-8D03-00A0C959BC0A`). Some such plugins ship with Windows and are marked as safe despite receiving very little security scrutiny.

One of the more important security properties of object-embedding tags is that like with many of their counterparts intended for embedding other non-HTML content, no particular attention is paid to server-supplied `Content-Type` and `Content-Disposition` headers, despite the fact that many embedded objects may in fact execute in a security context related to the domain that served them. 

The precedence of inputs for deciding how to interpret the content in various browsers is as follows:

|| <font color="#3050a0">*Input signal*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Tag type and `TYPE=` / `CLASSID=` values</font> || #1 || #1 || || #1 || #1 || #1 || #1 || #1 || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">`Content-Type` value if `TYPE=` is not recognized</font> || ignored || ignored || || ignored || ignored || ignored || ignored || ignored || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">`Content-Type=`value if `TYPE=` is missing</font> || #2 || #2 || || #2 || #2 || #2 || #2 || #2 || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Content sniffing if `TYPE=` is not recognized</font> || ignored || ignored || || ignored || ignored || ignored || ignored || ignored || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Content sniffing if `TYPE=` is missing</font> || ignored || ignored || || ignored || ignored || (#3) || ignored || (#3) || <font color="#909090">n/a</font> ||

The approach to determining how to handle the data with no attention to the intent indicated by the hosting server is a problematic design concept, as it makes it impossible for servers to opt out from having any particular resource being treated as a plugin-interpreted document in response to actions of a malicious third-party site. In conjunction with lax syntax parsers within browser plugins, this resulted in a number of long-standing vulnerabilities, such as valid Java archive files (JARs) [http://www.infoworld.com/article/08/08/01/A_photo_that_can_steal_your_online_credentials_1.html doubling as valid images].

=Standard browser security features=

This section provides a detailed discussion of explicit security mechanisms and restrictions implemented within browser. Long-standing design deficiencies are discussed, but no specific consideration is given to short-lived vulnerabilities.

==Same-origin policy=

Perhaps the most important security concept within modern browsers is the idea of same-origin security policies. The principal intent for these mechanisms is to make it possible for largely unrestrained scripting and other interactions between pages served as a part of the same site (understood as having a particular DNS host name, or part thereof), whilst almost completely preventing any interference between unrelated sites.

In practice, there is no single same-origin policy, but rather, a set of mechanisms with some superficial resemblance, but quite a few important differences. These flavors are discussed below.

===Same-origin policy for DOM access===

With no additional qualifiers, the term "same-origin policy" most commonly refers to a mechanism that governs the ability for Javascript and other scripting languages to access DOM properties and methods across domains ([http://developer.mozilla.org/En/Same_origin_policy_for_JavaScript reference]). In essence, the model boils down to this three-step decision process:

  * If protocol, host name, and port number for two interacting pages match, access is granted with no further checks.

  * Any page may set `document.domain` parameter to a right-hand, fully-qualified fragment of its current host name (e.g., `foo.bar.example.com` may set it to `example.com`, but not `ample.com`). If two pages explicitly and _mutually_ set their respective `document.domain` parameters to the same value, access is granted with no further checks.

  * If neither of the above conditions is satisfied, access is denied.

In theory, the model seems simple and robust enough to ensure proper separation between unrelated pages, and serve as a method for sandboxing potentially untrusted or risky content within a particular domain; upon closer inspection, quite a few drawbacks arise, however:

  * Firstly, the `document.domain` mechanism functions as a security tarpit: once any two legitimate subdomains in `example.com`, e.g. `www.example.com` and `payments.example.com`, choose to cooperate this way, any other resource in that domain, such as `user-pages.example.com`, may then set own `document.domain` likewise, and arbitrarily mess with `payments.example.com`. This means that in many scenarios, `document.domain` may not be used safely at all.

  * Whenever `document.domain` cannot be used - either because pages live in completely different domains, or because of the aforementioned security problem - legitimate client-side communication between, for example, embeddable page gadgets, is completely forbidden in theory, and in practice very difficult to arrange, requiring developers to resort to the abuse of known browser bugs, or to latency-expensive server-side channels, in order to build legitimate web applications.

  * Whenever tight integration of services within a single host name is pursued to overcome these communication problems, because of the inflexibility of same-origin checks, there is no usable method to sandbox any untrusted or particularly vulnerable content to minimize the impact of security problems.

On top of this, the specification is simplistic enough to actually omit quite corner cases; among other things:

  * The `document.domain` behavior when hosts are addressed by IP addresses, as opposed to fully-qualified domain names, is not specified.

  * The `document.domain` behavior with extremely vague specifications (e.g., `com` or `co.uk`) is not specified.

  * Many one-off exceptions to the model were historically made, be it intentionally to permit certain types of desirable interaction, such as the ability to point own frames or script-spawned windows to new locations, or by omission - and these are not well-documented.
 
  * The algorithms of context inheritance for pseudo-protocol windows, such as `about:blank`, are not specified.

  * The behavior for URLs that do not meaningfully have a host name associated with them (e.g., `file://`) is not defined, causing some browsers to permit locally saved files to access every document on the disk or on the web; users are generally not aware of this risk, potentially exposing themselves.

  * The behavior when a single name resolves to vastly different IP addresses (for example, one on an internal network, and another on the Internet) is not specified, permitting [http://crypto.stanford.edu/dns/ DNS rebinding] attacks and related tricks that put certain mechanisms (captchas, ad click tracking, etc) at extra risk.

All this ambiguity leads to a significant degree of variation between browsers, and historically, resulted in a large number of browser security flaws. A detailed analysis of DOM actions permitted across domains, as well as context inheritance rules, is given in later sections. A quick survey of several core same-origin differences between browsers is given below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">May `document.domain` be set to TLD alone?</font> || NO || NO || || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || <font color="#f0000">YES</font> || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">May `document.domain` be set to right-hand IP address fragments?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Do port numbers wrap around in same origin checks?</font> || NO || NO || || uint32 || uint32 || uint16/32 || uint16 || NO || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">May local HTML access unrelated local files via DOM?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">May local HTML access sites on the Internet via DOM?</font> || NO || NO || || NO || NO || <font color="#ff0000">YES</font> || NO || NO || <font color="#909090">tbd</font> ||

<b></b>

===Same-origin policy for XMLHttpRequest===

On top of scripted DOM access, all of the contemporary browsers also provide the [http://www.w3.org/TR/XMLHttpRequest/ XMLHttpRequest] Javascript API, by which scripts may make HTTP requests to their originating site, and read back data as needed. The mechanism was originally envisioned primarily to make it possible to read back XML responses (hence the name, and the `responseXML` property), but currently, is perhaps more often used to read back JSON messages, HTML, and arbitrary custom communication protocols, and serves as the foundation for much of the _web 2.0_ behavior of rapid UI updates not dependent on full-page transitions.

The set of security-relevant features provided by `XMLHttpRequest`, and not seen in other browser mechanisms, is as follows:

  * The ability to specify an arbitrary HTTP request method (via the `open()` method),
  * The ability to set custom HTTP headers on a request (via `setRequestHeader()`),
  * The ability to read back full response headers (via `getResponseHeader()` and `getAllResponseHeaders()`),
  * The ability to read back full response body as Javascript string (via `responseText` property).

Since all requests sent via `XMLHttpRequest` include a browser-maintained set of cookies for the target site, and given that the mechanism provides a far greater ability to interact with server-side components than any other feature available to scripts, it is extremely important to build in proper security controls. The set of checks implemented in all browsers for `XMLHttpRequest` is a close variation of DOM same-origin policy, with the following changes:

  * Checks for `XMLHttpRequest` targets do not take `document.domain` into account, making it impossible for third-party sites to mutually agree to permit cross-domain requests between them.

  * In some implementations, there are additional restrictions on protocols, header fields, and HTTP methods for which the functionality is available, or HTTP response codes which would be shown to scripts (see later).

Since the removal of `document.domain` made any sort of client-side cross-domain communications through `XMLHttpRequest` impossible, as a much-demanded extension, [http://www.w3.org/TR/access-control/ W3C proposal for cross-domain XMLHttpRequest] access control would permit cross-site traffic to happen under certain additional conditions. The scheme envisioned by the proponents is as follows:

   * `GET` requests with custom headers limited to a whitelist would be sent to the target system immediately, with no advance verification, based on the assumption that `GET` traffic is not meant to change server-side application state, and thus will have no lasting side effects. This assumption is theoretically sound, as per the "SHOULD NOT" recommendation spelled out in [http://www.faqs.org/rfcs/rfc2616.html RFC 2616], though is seldom observed in practice. Unless an appropriate HTTP header or XML directive appears in the response, the result would not be revealed to the requester, though.

   * Non-`GET` requests (`POST`, etc) would be preceded by a "preflight" `OPTIONS` request, again with only whitelisted headers permitted. Unless an appropriate HTTP header or XML directive is seen in response, the actual request would not be issued.

Even in its current shape, the mechanism would open some RFC-ignorant web sites to new attacks; some of the earlier drafts had more severe problems, too. As such, the functionality ended up being [https://bugzilla.mozilla.org/show_bug.cgi?id=424923 scraped in Firefox 3], and currently, is not available in any browser, pending further work. A [http://code.msdn.microsoft.com/xdsecuritywp competing proposal] from Microsoft, scheduled to make an appearance in Microsoft Internet Explorer 8, would implement a completely incompatible, safer, but less useful scheme, permitting sites to issue anonymous (cookie-less) cross-domain requests only. There seems to be an [http://ajaxian.com/archives/the-fight-for-cross-domain-xmlhttprequest ongoing feud] between these two factions, so it may take a longer while for any particular API to succeed, and it is not clear what security properties it would posses.

As noted earlier, although there is a great deal of flexibility in what data may be submitted via `XMLHttpRequest` to same-origin targets, various browsers blacklist subsets of HTTP headers to prevent ambiguous or misleading requests from being issued to servers and cached by the browser or by any intermediaries . These restrictions, often contradictory or incomplete, are as follows:

|| <font color="#3050a0">*HTTP header*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">`Accept`</font> || OK || OK || || OK || OK || OK || OK || OK || OK ||
|| <font color="#3050a0">`Accept-Charset`</font> || OK || OK || || OK || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> ||
|| <font color="#3050a0">`Accept-Encoding`</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || || OK || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> ||
|| <font color="#3050a0">`Accept-Language`</font> || OK || OK || || OK || OK || OK || OK || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> ||
|| <font color="#3050a0">`Cache-Control`</font> || OK || OK || || OK || OK || OK || <font color="#30ff30">BANNED</font> || OK || OK ||
|| <font color="#3050a0">`Cookie`</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || || OK || OK || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || OK ||
|| <font color="#3050a0">`If-*` family (`If-Modified-Since`, etc)</font> || OK || OK || || OK || OK || OK || <font color="#30ff30">BANNED</font> || OK || OK ||
|| <font color="#3050a0">`Host`</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> ||
|| <font color="#3050a0">`Range`</font> || OK || OK || || OK || OK || OK || <font color="#30ff30">BANNED</font> || OK || OK ||
|| <font color="#3050a0">`Referer`</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> ||
|| <font color="#3050a0">`Transfer-Encoding`</font> || OK || OK || || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> ||
|| <font color="#3050a0">`User-Agent`</font> || OK || OK || || OK || OK || <font color="#30ff30">BANNED</font> || OK || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> ||
|| <font color="#3050a0">`Via`</font> || OK || OK || || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> || <font color="#30ff30">BANNED</font> ||

A long-standing [http://www.securityfocus.com/archive/1/434931 security flaw] in Microsoft Internet Explorer 6 permits stray newline characters to appear in some `XMLHttpRequest` fields, permitting arbitrary headers (such as `Host`) to be injected into outgoing requests. This behavior needs to be accounted for in any scenarios where a considerable population of legacy MSIE6 users is expected.

Other important security properties of `XMLHttpRequest` are outlined below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Banned HTTP methods</font> || `TRACE` || `CONNECT` `TRACE`^*^ || || `TRACE` || `TRACE` || `CONNECT` `TRACE` || <font color="#ff0000">none</font> || `CONNECT` `TRACE` || `CONNECT` `TRACE` ||
|| <font color="#3050a0">`XMLHttpRequest` may see `httponly` cookies?</font> || <font color="#ff0000">YES</font> || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO ||
|| <font color="#3050a0">`XMLHttpRequest` may see invalid HTTP 30x responses</font>? || NO || NO || || YES || YES || NO || NO || YES || NO ||
|| <font color="#3050a0">`XMLHttpRequest` may see cross-domain HTTP 30x responses</font>? || NO || NO || || YES || YES || NO || NO || NO || NO ||
|| <font color="#3050a0">`XMLHttpRequest` may see other HTTP non-200 responses?</font> || YES || YES || || YES || YES || YES || YES || YES || NO ||
|| <font color="#3050a0">May local HTML access unrelated local files via `XMLHttpRequest`?</font> || NO || NO || || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">May local HTML access sites on the Internet via `XMLHttpRequest`?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#909090">tbd</font> ||

^*^ Implements a whitelist of known schemes, rejects made up values.

*WARNING:* Microsoft Internet Explorer 7 may be forced to partly regress to the less secure behavior of the previous version by invoking a proprietary, legacy `ActiveXObject('MSXML2.XMLHTTP')` in place of the new, native `XMLHttpRequest` API.

Please note that the degree of flexibility offered by `XMLHttpRequest`, and not seen in other cross-domain content referencing schemes, may be actually used as a simple security mechanism: a check for a custom HTTP header may be carried out on server side to confirm that a cookie-authenticated request comes from Javascript code that invoked `XMLHttpRequest.setRequestHeader()`, and hence must be triggered by same-origin content, as opposed to a random third-party site. This provides a coarse [http://en.wikipedia.org/wiki/Cross-site_request_forgery cross-site request forgery] defense, although the mechanism may be potentially subverted by the incompatible same-origin logic within some plugin-based programming languages, as discussed [#Same-origin_policy_for_Flash later on].

===Same-origin policy for cookies===

As the web started to move from static content to complex applications, one of the most significant problems with HTTP was that the protocol contained no specific provisions for maintaining any client-associated context for subsequent requests, making it difficult to implement contemporary mechanisms such as convenient, persistent authentication or preference management ([http://tools.ietf.org/html/rfc2617 HTTP authentication], as discussed [#HTTP_authentication later on], proved to be too cumbersome for this purpose, while any in-URL state information would be often accidentally disclosed to strangers or lost). To address the need, HTTP cookies were implemented in Netscape Navigator (and later submitted as [http://www.ietf.org/rfc/rfc2109.txt RFC 2109]): any server could return a short text token to be stored by the client in a `Set-Cookie` header, and the token would be stored by clients and included on all future requests (in a `Cookie` header).

Key properties of the mechanism:

  * *Header structure:* every `Set-Cookie` header sent by the server consists of one or more comma-separated `NAME=VALUE` pairs, followed by a number of additional semicolon-separated parameters or keywords. In practice, a vast majority of browsers support only a single pair (confusingly, multiple `NAME=VALUE` pairs are accepted in all browsers via `document.cookie`, a simple Javascript cookie manipulation API). Every `Cookie` header sent by the client consists of any number of semicolon-separated `NAME=VALUE` pairs with no additional metadata.

  * *Scope:* by default, cookie scope is limited to all URLs on the current host name. Scope may be limited with `path=` parameter to specify a specific path prefix to which the cookie should be sent, or broadened to a group of DNS names, rather than single host only, with `domain=`. The latter operation may specify any fully-qualified right-hand segment of the current host name, up to one level below TLD (in other words, `www.foo.bar.example.com` may set a cookie to be sent to `*.bar.example.com` or `*.example.com`, but not to `*.something.else.example.com` or `*.com`). Domain wildcards in cookie specifications are marked with a preceeding period, so `.example.com` denotes a wildcard match for the entire domain - including, somewhat confusingly `example.com` proper - whereas `foo.example.com` denotes an exact host match.

  * *Time to live:* by default, each cookie has a lifetime limited to the duration of the current browser session (in practice meaning that it is stored in program memory only, and not written to disk). Alternatively, an `expires=` parameter may be included to specify the date (in one of a large number of possible [http://lxr.mozilla.org/mozilla1.8.0/source/nsprpub/pr/src/misc/prtime.c#961 confusing and hard-to-parse] date formats) at which the cookie should be dropped. This automatically enables persistent storage of the cookie.

  * *Overwriting cookies:* if a new cookie with the same `NAME`, `domain`, and `path` as an existing cookie is encountered, the old cookie is discarded. Otherwise, even if a subtle difference exists (e.g., two distinct `domain=` values in the same top-level domain), the two cookies will co-exist, and may be sent by the client at the same time as two separate pairs in `Cookie` headers, with no additional information to help resolve the conflict.

  * *Deleting cookies:* There is no specific mechanism for deleting cookies envisioned, although a common hack is to overwrite a cookie with a bogus value as outlined above, plus a backdated or short-lived `expires=` field.

  * *"Protected" cookies:* as a security feature, some cookies set may be marked with a special `secure` keyword, which causes them to be sent over HTTPS only. Note that non-HTTPS sites may still set `secure` cookies in some implementations, just not read them back.

The original design for HTTP cookies has multiple problems and drawbacks that resulted in various security problems and kludges to address them:

  * *Privacy issues:* the chief concern with the mechanism was that it permitted scores of users to be tracked extensively across any number of collaborating domains without permission (in the simplest form, by simply including tracking code in an `IFRAME` pointing to a common `evil-tracking.com` resource on any number of web pages, so that the same `evil-tracking.com` cookie can be correlated across all properties). It is a major misconception that HTTP cookies were the only mechanism to store and retrieve long-lived client-side tokens - for example, [http://lists.openwall.net/full-disclosure/2004/01/19/46 cache validation directives] may be naughtily repurposed to implement a very similar functionality - but the development nevertheless caused public outcry.<p />Widespread criticism eventually resulted in many browsers enabling restrictions on any included content on a page setting cookies for any domain other than that displayed in the URL bar (discussed [#Third-party_cookie_rules later on]), despite the fact that such a measure would not stop cooperating sites from tracking users using marginally more sophisticated methods. A minority of users to this day browses with cookies disabled altogether for similar reasons, too.

  * *Problems with ccTLDs:* the specification did not account for the fact that many country-code TLDs are governed by odd or sometimes conflicting rules. For example, `waw.pl`, `com.pl`, and `co.uk` should be both seen as generic, functional top-level domains, and so it should not be possible to set cookies at this level, as to avoid interference between various applications; but `example.pl` or `coredump.cx` are single-owner domains for which it should be possible to set cookies. This resulted in many browsers having serious trouble collecting empirical data from various ccTLDs and keeping it in sync with the current state of affairs in the DNS world.

  * *Problems with conflict resolution:* when two identically named cookies with different scopes are to be sent in a single request, there is no information available to the server to resolve the conflict and decide which cookie came from where, or how old it is. Browsers do not follow any specific conventions on the ordering of supplied cookies, too, and some behave in an outright buggy manner. Additional metadata to address this problem is proposed in "cookies 2" design ([http://tools.ietf.org/rfc/rfc2965.txt RFC 2965]), but the standard never gained widespread support.

  * *Problems with certain characters:* just like HTTP, cookies have no specific provisions for character escaping, and no specified behavior for handling of high-bit and control characters. This sometimes results in completely unpredictable and [http://b/issue?id=978119 dangerous situations] if not accounted for.

  * *Problems with cookie jar size:* standards do not specify cookie count limits or pruning strategies. Various browsers may implement various total and per-domain caps, and the behavior may result in malicious content purposefully disrupting session management, or legitimate content doing so by accident.

  * *Perceived Javascript-related problems:* the aforementioned `document.cookie` Javascript API permits for Javascript embedded on pages to access sensitive authentication cookies. If malicious scripts may be planted on a page due to insufficient escaping of user input, these cookies could be stolen and disclosed to the attacker. The concern for this possibility resulted in [http://msdn.microsoft.com/en-us/library/ms533046.aspx httponly cookie flag] being incorporated into Microsoft Internet Explorer, and later other browsers; such cookies would not be visible through `document.cookie` (but, as noted in the previous section, are not always adequately hidden in `XMLHttpRequest` calls). In reality, the degree of protection afforded this way is minimal, given the ability to interact with same-origin content through DOM.

  * *Problems with "protected" cookie clobbering:* as indicated earlier, `secure` and `httponly` cookies are meant not to be visible in certain situations, but no specific thought was given to preventing Javascript from overwriting `httponly` cookies, or non-encrypted pages from overwriting `secure` cookies. This oversight could be abused to subvert at least some usage scenarios.

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Does `document.cookie` work on `ftp` URLs?</font> || NO || NO || || NO || NO || NO || NO || NO || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Does `document.cookie` work on `file` URLs?</font> || YES || YES || || YES || YES || YES || YES || NO || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">Is `Cookie2` standard supported?</font> || NO || NO || || NO || NO || NO || <font color="#30ff30">YES</font> || NO || NO ||
|| <font color="#3050a0">Are multiple comma-separated `Set-Cookie` pairs accepted?</font> || NO || NO || || NO || NO || <font color="#ff0000">YES</font> || NO || NO || NO ||
|| <font color="#3050a0">Is `httponly` flag supported?</font> || YES || YES || || YES || YES || <font color="#ff0000">NO</font> || YES || YES || <font color="#ff0000">NO</font> ||
|| <font color="#3050a0">Can scripts clobber `httponly` cookies?</font> || NO || NO || || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">(YES)</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">(YES)</font> ||
|| <font color="#3050a0">Ordering of duplicate cookies with different scope</font> || <font color="#ff0000">random</font> || <font color="#ff0000">random</font> || || <font color="#ff0000">some dropped</font> || <font color="#30ff30">most specific first</font> || <font color="#ff0000">random</font> || <font color="#30ff30">most specific first</font> || <font color="#30ff30">most specific first</font> || <font color="#ff0000">by age</font> ||
|| <font color="#3050a0">Maximum length of a single cookie</font> || 4 kB || 4 kB || || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || <font color="#ff0000">broken</font> ||
|| <font color="#3050a0">Maximum number of cookies per site</font> || 50 || 50 || || <font color="#ff0000">∞</font> || 100 || <font color="#ff0000">∞</font> || <font color="#ff0000">∞</font> || ~70 || 50 ||
|| <font color="#3050a0">Are cookies for right-hand IP address fragments accepted?</font> || NO || NO || || NO || NO || <font color="#ff0000">YES</font> || NO || NO || NO ||
|| <font color="#3050a0">Overly permissive ccTLD behavior test results (3 tests)</font> || <font color="#ff0000">1/3 FAIL</font> || <font color="#ff0000">1/3 FAIL</font> || || <font color="#ff0000">2/3 FAIL</font> || <font color="#30ff30">3/3 OK</font> || <font color="#ff0000">2/3 FAIL</font> || <font color="#30ff30">3/3 OK</font> || <font color="#30ff30">3/3 OK</font> || <font color="#ff0000">2/3 FAIL</font> || 

===Same-origin policy for Flash===

[http://en.wikipedia.org/wiki/Adobe_Flash Adobe Flash], a plugin believed to be installed on about [http://www.adobe.com/products/player_census/flashplayer/ 99% of all desktops], incorporates a security model generally inspired by browser same-origin checks. Flash applets have their security context derived from the URL they are loaded from (as opposed to the site that embeds them with `<OBJECT>` or `<EMBED>` tags), and within this realm, permission control follows the same basic principle as applied by browsers to DOM access: protocol, host name, and port of the requested resource is compared with that of the requestor, with universal access privileges granted to content stored on local disk. That said, there are important differences - and some interesting extensions - that make Flash capable of initiating cross-domain interactions to a degree greater than typically permitted for native browser content.

Some of the unique properties and gotchas of the current Flash security model include:

  * The ability for sites to provide a [http://livedocs.adobe.com/flex/3/html/05B_Security_03.html#122782 cross-domain policy], often referred to as `crossdomain.xml`, to allow a degree of interaction from non-same-origin content. Any non-same-origin Flash applet may specify a location on the target server at which this XML-based specification should be looked up; if it matches a specific format, it would be interpreted as a permission to carry out cross-domain actions.<p />Historically, the mechanism, due to extremely lax XML parser and no other security checks in place, posed a major threat: many types of user content, for example images or text files, could be trivially made to mimick such data without site owner's knowledge or consent. [http://www.adobe.com/devnet/flashplayer/articles/fplayer9_security_02.html Recent security improvements] enabled a better control of cross-domain policies; this includes a more rigorous XML parser; a requirement for MIME type on policies to match `text/*`, `application/xml`, or `application/xhtml+xml`; or the concept of [http://www.adobe.com/devnet/flashplayer/articles/fplayer9_security_03.html site-wide meta-policies], stored at a fixed top-level location - `/crossdomain.xml`. These policies would specify global security rules, and for example prevent any lower-order policies from being interpreted, or require MIME type on all policies to non-ambiguously match `text/x-cross-domain-policy`.

  * The ability to make cookie-bearing cross-domain HTTP `GET` and `POST` requests via the browser stack, with fewer constraints than typically seen elsewhere in browsers. This is achieved through the [http://livedocs.adobe.com/flex/3/langref/flash/net/URLRequest.html URLRequest] API. The functionality, most notably, includes the ability to specify arbitrary `Content-Type` values, and to send binary payloads. Historically, Flash would also permit nearly arbitrary headers to be appended to cross-domain traffic via the `requestHeaders` property, although this had changed with [http://www.adobe.com/devnet/flashplayer/articles/flash_player9_security_update.html a series of recent security updates], now requiring an explicit `crossdomain.xml` directive to re-enable the feature.

  * The ability to make same-origin HTTP requests, including setting and reading back HTTP headers to an extent greater than that of `XMLHttpRequest` ([http://livedocs.adobe.com/flex/3/langref/flash/net/URLRequestHeader.html list of banned headers]).

  * The ability to [http://livedocs.adobe.com/flex/3/html/05B_Security_10.html#145624 access to raw TCP sockets] via `XMLSockets`, to connect back to the same-origin host on any high port (> 1024), or to access third-party systems likewise. Following recent security updates, this requires explicit cross-domain rules, although these may be easily provided for same-origin traffic. In conjunction with [http://crypto.stanford.edu/dns/ DNS rebinding attacks] or the behavior of certain firewall helpers, the mechanism could be abused to punch holes in the firewall or [http://scan.flashsec.org/ probe local and remote systems], although certain mitigations were incorporated since then.

  * The ability for applet-embedding pages to restrict certain permissions for the included content by specifying `<OBJECT>` or `<EMBED>` parameters:<p />
    * The ability to load external files and navigate the current browser window ([http://livedocs.adobe.com/flex/3/html/help.html?content=05B_Security_05.html#150192 allowNetworking] attribute).<p />
    * The ability to interact with on-page Javascript context ([http://livedocs.adobe.com/flex/3/html/05B_Security_14.html#131683 allowScriptAccess] attribute; previously unrestricted by default, now limited to `sameDomain`, which requires the accessed page to be same origin with the applet).<p />
    * The ability to run in full-screen mode ([http://livedocs.adobe.com/flex/3/html/05B_Security_06.html#152029 allowFullScreen] attribute).

This model is further mired with other bugs and oddities, such as the reliance on [http://my.opera.com/hallvors/blog/2007/10/22/a-malicious-thought-how-to-imagine-a-security-issue location.* DOM being tamper-proof] for the purpose of executing same-origin security checks,

Flash applets running from the Internet do not have any specific permissions to access local files or input devices devices, although depending on user configuration decisions, some or all sites may use a limited quota within a virtualized data storage sandbox, or access the microphone.

===Same-origin policy for Java===

Much like Adobe Flash, [http://java.sun.com/applets/ Java applets], reportedly supported on about 80% of all desktop systems, follow the basic concept of same-origin checks applied to a runtime context derived from the site the applet is downloaded from. The documentation for Java security model available on the Internet appears to be remarkably poor and spotty, so the information provided in this section is in large part based on empirical testing. According to this research, the following permissions are available to Java applets:

  * The ability to interact with Javascript on the embedding page through the [http://java.sun.com/j2se/1.4.2/docs/guide/plugin/developer_guide/java_js.html JSObject] API, with no specific same-origin checks. This mechanism is disabled by default, but may be enabled with the `MAYSCRIPT` parameter within the `<APPLET>` tag.

  * In some browsers, the ability to interact with the embedding page through the [http://java.sun.com/j2se/1.4.2/docs/guide/plugin/developer_guide/java_js.html DOMService] API. The documentation does not state what, if any, same-origin checks should apply; based on the aforementioned tests, no checks are carried out, and cross-domain embedding pages may be accessed freely with no need for `MAYSCRIPT` opt-in. This directly contradicts the logic of `JSObject` API.

  * The ability to send same-origin HTTP requests using the browser stack via the [http://java.sun.com/j2se/1.4.2/docs/api/java/net/URLConnection.html URLConnection] API, with virtually no security controls, including the ability to set `Host` headers, or insert conflicting caching directives. On the upside, it appears that there is no ability to read 30x redirect bodies or `httponly` cookies from within applets.

  * The ability to initiate unconstrained TCP connections back to the originating host, and that host only, using the [http://java.sun.com/j2se/1.4.2/docs/api/java/net/Socket.html Socket] API. These connections do not go through the browser, and are not subject to any additional security checks (e.g., ports such as `25/tcp` are permitted).

Depending on the configuration, the user may be prompted to give signed applets greater privileges, including the ability to read and write local files, or access specific devices. Unlike Flash, Java has no cross-domain policy negotiation features.

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is `DOMService` supported?</font> || YES || YES || || NO || NO || YES || NO || YES || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Does `DOMService` permit cross-domain access to embedding page?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || <font color="#ff0000">YES</font> || <font color="#909090">n/a</font> || <font color="#ff0000">YES</font> || <font color="#909090">n/a</font> ||

<b></b>

===Same-origin policy for Silverlight===

[http://en.wikipedia.org/wiki/Silverlight Microsoft Silverlight] 2.0 is a recently introduced content rendering browser plugin, and a competitor to Adobe Flash. 

There is some uncertainty about how likely the technology is to win widespread support, and relatively little external security research and documentation available, so this section serves as a placeholder for time being. In principle, however, Silverlight appears to closely mimick the same-origin model implemented for Flash:

  * Security context for the application is derived from the URL it is included from. Access to the embedding HTML document is permitted by default for same-origin HTML, and controlled by [http://msdn.microsoft.com/en-us/library/cc838264(VS.95).aspx enableHtmlAccess] parameter elsewhere. Microsoft security documentation does not clearly state if scripts have permission to navigate browser windows in absence of `enableHtmlAccess`, however.

  * Same-origin HTTP requests may be issued via `HttpWebRequest` API, and may contain arbitrary payloads - but there are certain restrictions on which HTTP headers may be modified. The exact list of restrictions headers is not given by Microsoft, however ([http://msdn.microsoft.com/en-us/library/system.net.httpwebrequest.headers(VS.95).aspx reference]).

  * Cross-domain HTTP and network access is not permitted until a policy compatible with Flash `crossdomain.xml` or Silverlight `clientaccesspolicy.xml` format, is furnished by the target host. Microsoft documentation implies that "unexpected" MIME types are rejected, but this is not elaborated upon; it is also not clear how strict the parser is ([http://msdn.microsoft.com/en-us/library/cc645032(VS.95).aspx reference]).

  * Non-HTTP network connectivity uses `System.Net.Sockets`. Raw connections to same-origin systems are not permitted until an appropriate cross-domain policy is furnished ([http://msdn.microsoft.com/en-us/library/cc645032(VS.95).aspx reference]).

  * Acess between HTTP and HTTPS schemes is apparently considered same-origin, and does not require a cross-domain specification ([http://msdn.microsoft.com/en-us/library/cc189008(VS.95).aspx reference]).

===Origin inheritance rules===

As [#Pseudo_URL_schemes hinted earlier], certain types of pseudo-URLs, such as `javascript:`, `data:`, or `about:blank`, do not have any inherent same-origin context associated with them the way `http://` URLs have - which poses a special problem in the context of same-origin checks. 

If a shared "null" security context is bestowed upon all these resources, and checks against this context always succeed, a risk arises that blank windows spawned by completely unrelated sites and used for different purposes could interfere with each other. The possibility is generally prevented in most browsers these days, but had caused a fair number of problems in the past (see [https://bugzilla.mozilla.org/show_bug.cgi?id=343168 Mozilla bug 343168] and [http://crypto.stanford.edu/websec/frames/navigation/ related work] by Adam Barth and Collin Jackson for a historical perspective). On the other hand, if all access to such windows is flat out denied, this would go against the expectation of legitimate sites to be able to scriptually access own `data:` or `about:blank` windows.

Various browsers accommodate this ambiguity in different ways, often with different rules for document-embedded `<IFRAME>` containers, for newly opened windows, and for descendants of these windows. 

A quick survey of implementations is shown below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Inherited context for domain-less IFRAMEs</font> || parent || parent || || parent || parent || parent || parent || parent || parent ||
|| <font color="#3050a0">Inherited context for `about:blank` windows</font> || parent || parent || || no access || no access || parent || parent || parent || parent ||
|| <font color="#3050a0">Inherited context for `javascript:` windows</font> || parent || parent || || parent || parent || <font color="#909090">n/a</font> || parent || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || 
|| <font color="#3050a0">Inherited context for `data:` windows</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || || parent || parent || no access || blank || no access || no access ||

<b></b>

===Cross-site scripting and same-origin policies===

Same-origin policies are generally perceived as one of most significant bottlenecks associated with contemporary web browsers. To application developers, the policies are too strict and inflexible, serving as a major annoyance and stifling innovation; the developers push for solutions such as cross-domain `XMLHttpRequest` or `crossdomain.xml` in order to be able to build and seamlessly integrate modern applications that span multiple domains and data feeds. To security engineers, on the other hand, these very same policies are too loose, putting user data at undue risk in case of minor and in practice nearly unavoidable programming errors.

The security concern traces back to the fact that the structure of HTML as such, and the practice for rendering engines to implement very lax and poorly documented parsing of legacy HTML features, including extensive and incompatible error recovery attempts, makes it difficult for web site developers to render user-controlled information without falling prey to [http://code.google.com/p/doctype/wiki/ArticleXSS HTML and script injection flaws]. A number of poorly designed, browser-side content sniffing and character set strategies (discussed later in this document), further contributes to the problem by making it likely for non-HTML content to be misinterpreted and rendered as HTML anyway.

Because of this, nearly every major web service routinely suffers from numerous HTML injection flaws; [http://xssed.com/archive xssed.com], an external site dedicated to tracking publicly reported issues of this type, amassed over 50,000 entries in under two years.

The problem clearly demonstrates the inadequateness of same-origin policies as statically bound to a single domain: not all content shown on a particular site should or may be trusted the same, and permitted to do the same. The ability to either isolate, or restrict privileges for portions of data that currently enjoy unconstrained same-origin privileges, would mitigate the impact of HTML parsing problems and developer errors, and also enable new types of applications to be securely built, and is the focus of many experimental security mechanisms proposed for future browsers (as outlined [#Experimental_and_legacy_security_mechanisms later on]).

==Life outside same-origin rules==

Various flavors of same-origin policies define a set of restrictions for several relatively recent and particularly dangerous operations in modern browsers - DOM access, `XMLHttpRequest`, cookie setting - but as originally envisioned, the web had no security boundaries built in, and no particular limitations were set on what resources pages may interact with, or in what manner. This promiscuous design holds true to this date for many of the core HTML mechanisms, and this degree of openness likely contributed to the overwhelming success of the technology.

This section discusses the types of interaction not subjected to same-origin checks, and the degree of cross-domain interference they may cause.

===Navigation and content inclusion across domains===

There are numerous mechanisms that permit HTML web pages to include and display remote sub-resources through HTTP `GET` requests without having these operations subjected to a well-defined set of security checks:

  * *Simple multimedia markup:* tags such as `<IMG SRC="...">` or `<BGSOUND SRC="...">` permit `GET` requests to be issued to other sites with the intent of retrieving the content to be displayed. The received payload is then displayed on the current page, assuming it conforms to one of the internally recognized formats. In current designs, the data embedded this way remains opaque to Javascript, however, and cannot be trivially read back ([https://bugzilla.mozilla.org/show_bug.cgi?id=451619 except for occasional bugs]).

  * *Remote scripts:* `<SCRIPT SRC="...">` tags may be used to issue `GET` requests to arbitrary sites, likewise. A relatively relaxed Javascript (or E4X XML) parser is then applied to the received content; if the response passes off as something resembling structurally sound Javascript, this cross-domain payload may then be revealed to other scripts on the current page; one way to achieve this goal is through redefining callback functions or modifying object prototypes; some browsers further help by providing verbose error messages to `onerror` handlers. The possibility of cross-domain data inclusion poses a risk for all sensitive, cookie-authenticated JSON interfaces, and some other document formats not originally meant to be Javascript, but resembling it in some aspects (e.g., XML, CSV).

  * *Remote stylesheets:* `<LINK REL="stylesheet" HREF="...">` tags may be used in a manner similar to `<SCRIPT>`. The returned data would be subjected to a considerably more rigorous [http://www.w3.org/Style/CSS/ CSS syntax] parser. The odds of random non-CSS data passing this validation are low, and so is the incidence of dynamic stylesheets that could reveal any sensitive information across domains - although in principle, a similar risk to that of `<SCRIPT>` exists also in this case. Once properly parsed, CSS data may be disclosed to scripts through [http://blog.stchur.com/2006/06/21/css-computed-style/ getComputedStyle or currentStyle properties] (the former is W3C-mandated).

  * *Embedded objects and applets:* `<EMBED SRC="...">`, `<OBJECT CODEBASE="...">`, and `<APPLET CODEBASE="...">` tags permit arbitrary resources to be retrieved via `GET` and then supplied as input to browser plugins. The exact effect of this action depends on the plugin to which the resource is routed, a factor entirely controlled by the author of the page. The impact is that content never meant to be interpreted as a plugin-based program may end up being interpreted and executed in a security context associated with the serving host. Some of these risks are discussed in more detail in our [http://wiki/Main/ISETeamFileHosting file hosting security] guidelines.

  * *Document-embedded frames:* `<FRAME>` `<IFRAME>` elements may be used to create new document rendering containers within the current browser window, and to fetch any target documents via `GET`. These documents would be subject to same-origin checks once loaded.

Note that on all of the aforementioned inclusion schemes other than `<FRAME>` and `<IFRAME>`, any `Content-Type` and `Content-Disposition` HTTP headers returned by the server for the sub-resource are completely ignored; there is no opportunity to authoritatively instruct the browser about the intended purpose of a served document to prevent having the data parsed as Javascript, CSS, etc.

In addition to these content inclusion methods, multiple ways exist for pages to initiate full-page transitions to remote content (which causes the target document for such an operation to be replaced with a brand new document in a new security context):

  * *Link targets:* the current document, any other named window or frame, or one of special window classes (`_blank`, `_parent`, `_self`, `_top`) may be targeted by `<A HREF="...">` to initiate a regular, `GET`-based page transition. In some browsers, such a link may be also automatically "clicked" by Javascript with no need for user interaction (for example, using the `click()` method).

  * *`Refresh` and `Location` directives:* HTTP `Location` and `Refresh` headers, as well as `<META HTTP-EQUIV="Refresh" VALUE="...">` directives, may be used to trigger a `GET`-based page transition, either immediately or after a predefined time interval.

  * *Javascript DOM access:* Javascript code may directly access `location.*`, `window.open()`, or `document.URL` to automatically trigger `GET` page transitions, likewise.

  * *Form submission:* HTML `<FORM ACTION="...">` tags may be used to submit `POST` and `GET` requests to remote targets. Such transitions may be triggered automatically by Javascript by calling the `submit()` method. `POST` forms may contain payloads constructed out of form field name-value pairs (both controllable through `<INPUT NAME="..." VALUE="...">` tags), and encoded according to [http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1 application/x-www-form-urlencoded] (`name1=value1&name2=value2...`, with `%nn` encoding of non-URL-safe characters), or to [http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2 multipart/form-data] (a complex, chunked MIME-like format), depending on `ENCTYPE=` parameter.<p />In addition, some browsers permit [http://reference.sitepoint.com/html/form/enctype text/plain] to be specified as `ENCTYPE`; in this mode, URL encoding is not applied to `name=value` pairs, allowing almost unconstrained cross-domain `POST` payloads.<p />_Trivia: `POST` payloads are opaque to Javascript. Without server-side cooperation, or the ability to inspect the originating page, there is no possibility for scripts to inspect the data posted in the request that produced the current page. The property might be relied upon as a crude security mechanism in some specific scenarios, although it does not appear particularly future-safe._

Related tests:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Are verbose `onerror` messages produced for `<SCRIPT>`?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Are verbose `onerror` messages produced for `<STYLE>`?</font> || NO || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Can links be auto-clicked via `click()`?</font> || YES || YES || || NO || NO || NO || YES || NO || NO ||
|| <font color="#3050a0">Is `getComputedStyle` supported for CSS? (W3C)</font> || NO || NO || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is `currentStyle` supported for CSS? (Microsoft)</font> ||  YES || YES || || NO || NO || NO || YES || NO || NO ||
|| <font color="#3050a0">Is `ENCTYPE=text/plain` supported on forms</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || NO ||

Note that neither of the aforementioned methods permits any control over HTTP headers. As [#Plugin-supported_content noted earlier], more permissive mechanisms may be available to plugin-interpreted programs and other non-HTML data, however.

===Arbitrary page mashups (UI redressing)===

Yet another operation permitted across domains with no specific security checks is the ability to seamlessly merge `<IFRAME>` containers displaying chunks of third-party sites (in their respective security contexts) inside the current document. Although this feature has no security consequences for static content - and in fact, might be desirable - it poses a significant concern with complex web applications where the user is authenticated with cookies: the attacker may cleverly decorate portions of such a third-party UI to make it appear as if they belong to his site instead, and then trick his visitors into interacting with this mashup. If successful, clicks would be directed to the attacked domain, rather than attacker's page - and may result in undesirable and unintentional actions being taken in the context of victim's account.

There are several basic ways to fool users into generating such misrouted clicks:

  * *Decoy UI underneath, proper UI made transparent using CSS `opacity` attribute:* many browsers permit page authors to set transparency on cross-domain `<IFRAME>` tags. Low opacity may result in the attacked cross-domain UI being barely visible, or not visible at all, with the browser showing attacker-controlled content placed underneath instead. Any clicks intended to reach attacker's content would still be routed to the invisible third-party UI overlaid on top, however.

  * *Decoy UI on top, with a small fragment not covered:* the attacker may also opt for showing the entire UI of the targeted application in a large `<IFRAME>`, but then cover portions of this container with opaque `<DIV>` or `<IFRAME>` elements placed on top (higher CSS `z-index` values). These overlays would be showing his misleading content instead, spare for the single button borrowed from the UI underneath.

  * *Keyhole view of the attacked application:* a variant of the previous attack technique is to simply make the `<IFRAME>` very small, and scroll this view to a specific X and Y location where the targeted button is present. Luckily, all current browser no longer permit cross-domain `window.scrollTo()` and `window.scrollBy()` calls - although the attack is still possible if useful [http://webmastercourse.com/articles/anchors/ HTML anchors] on the target page may be repurposed.

  * *Race condition attacks:* lastly, the attacker may simply opt for hiding the target UI underneath his own, and reveal it only miliseconds before the anticipated user click, not giving the victim enough time to notice the switch, or react in any way. Scripts have the ability to track mouse speed and position over the entire document, but it is still relatively difficult to reliably anticipate the timing of single, casual clicks. Timing solicited clicks (e.g. in action games) is easier, but there is a prerequisite of having an interesting and broadly appealing game to begin with.

In all cases, the attack is challenging to carry out given the deficiencies and incompatibilities of CSS implementations, and the associated difficulty of determining the exact positioning for the targeted UI elements. That said, real-world exploitation is not infeasible. In two of the aforementioned attack scenarios, the fact that that the invisible container may follow mouse pointer on the page makes it somewhat easier to achieve this goal, too.

Also note that the same UI redress possibility applies to `<OBJECT>`, `<EMBED>`, and `<APPLET>` containers, although typically with fewer security implications, given the typical uses of these technologies. 

UI redress attacks gained some prominence in 2008, after Jeremiah Grossman and Robert 'RSnake' Hansen coined the term _clickjacking_ and [http://ha.ckers.org/blog/20080915/clickjacking/ presented the attack to the public]. Discussions with browser vendors on possible mitigations are taking place, but no definitive solutions are to be expected in the short run. So far, the only product that offers partial protection against the possibility is [http://hackademix.net/2008/10/08/hello-clearclick-goodbye-clickjacking/ NoScript] (with the recently introduced ClearClick extension). On the flip side, no real-world cases of active exploitation are publicly known as of this writing.

There are no particularly reliable and non-intrusive ways for applications to prevent attacks; one possibility is to include Javascript to detect having the page rendered within a cross-domain `<IFRAME>`, and try to break out of it, e.g.:

{{{
try {
  if (top.location.hostname != self.location.hostname) throw 1;
} catch (e) {
  top.location.href = self.location.href;
}
}}}

It should be noted that there is no strict guarantee that the update of `top.location` would always work, particularly if dummy setters are defined, or if there are collaborating, attacker-controlled `<IFRAME>` containers performing conflicting location updates through various mechanisms. A more drastic solution would be to also overwrite or hide the current document pending page transition, or to perform `onclick` checks on all UI actions, and deny them from within frames. All of these mechanisms also fail if the user has Javascript disabled globally, or for the attacked site. 

Likewise, because of the features of Javascript, the following is enough to prevent frame busting in Microsoft Internet Explorer 7:

{{{
<script>
var location = "clobber";
</script>
<iframe src="http://www.example.com/frame_busting_code.html"></iframe>
}}}

Relevant tests:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is CSS `opacity` supported ("decoy underneath")?</font> || NO || NO || YES || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Are partly obstructed `IFRAME` containers clickable ("decoy on top")?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is cross-domain `scrollBy` scrolling permitted?</font> || NO || NO || || NO || NO || NO || NO || NO || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Is cross-domain anchor-based frame positioning permitted?</font> || YES || YES || || YES || YES || YES || YES || YES || <font color="#909090">n/a</font> ||

<b></b>

===Gaps in DOM access control===

For compatibility or usability reasons, and sometimes out of simple oversight, certain DOM properties and methods may be invoked across domains without the usual same-origin check carried out elsewhere. These exceptions to DOM security rules include:

  * *The ability to look up named third-party windows by their name:* by design, all documents have the ability to obtain handles of all standalone windows and `<IFRAME>` objects they spawn from within Javascript. Special builtin objects also permit them to look up the handle of the document that embeds them as a sub-resource, if any (`top` and `parent`); and the document that spawned their window (`opener`).<p />On top of this, however, many browsers permit arbitrary other named window to be looked up using `window.open('',<name>)`, regardless of any relation - or lack thereof - between the caller and the target of this operation. This poses a potential security problem (or at least may be an annoyance) when multiple sites are open simultaneously, one of them rogue: although most of user-created windows and tabs are not named, many script-opened windows, IFRAMEs, or "open in new window" link targets, have specific names.

  * *The ability to navigate windows with known handles or names:* subject to certain browser-specific restrictions, browsers may also change the location of windows for which names or Javascript handles may be obtained. Name-based location changes may be achieved through `window.open(<url>,<name>)` or - outside Javascript - via `<A HREF="..." TARGET="...">` links (which, as discussed in previous section, in some browsers may be automatically clicked by scripts). Handle-based updates rely on accessing `<win>.location.*` or `document.URL` properties, calling `<win>.location.assign()` or `<win>.location.replace()`, invoking `<win>.history.*` methods, or employing `<win>.document.write`.

  * *Assorted coding errors:* a number of other errors and omissions exists, some of which are even depended on to implement legitimate cross-domain communication channels. This category includes missing security checks on `window.opener`, `window.name`, or `window.on*` properties, the ability for parent frames to call functions in child's context, and so forth. [http://lcamtuf.coredump.cx/dom_checker/ DOM Checker] is a tool designed to enumerate many of these exceptions and omissions.<p />An important caveat of these mechanisms is that the missing checks might be just as easily used to establish much needed cross-domain communication channels, as they might be abused by third-party sites to inject rogue data into these streams.

  * *[https://developer.mozilla.org/En/DOM:window.postMessage window.postMessage API]:* this new mechanism introduced in several browsers permits two willing windows who have each other's handles to exchange text-based messages across domains as an explicit feature. The receiving party must opt in by registering an appropriate event handler (via `window.addEventListener()`), and has the opportunity to examine `MessageEvent.origin` property to make rudimentary security decisions.

A survey of these exceptions is summarized below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Can `window.open()` look up unrelated windows]]</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font>^*^ || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Can `frames[]` look up unrelated windows]]</font> || NO || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Can `<win>.frames[]` access third-party IFRAMEs?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font>^*^ || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Is `<win>.frames[]` iterator permitted?</font> ||  <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || (NO) || NO || NO ||
|| <font color="#3050a0">Can `window.open()` reposition unrelated windows?</font> ||  <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font>^*^ || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Can `<win>.history.*` methods be called on unrelated targets?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font>^*^ || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Can `<win>.location.*` properties be set on unrelated targets?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font>^*^ || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Can `<win>.location.*` methods be called on unrelated targets?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font>^*^ || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Can `<win>.document.write()` be called on unrelated targets?</font> || NO || NO || || <font color="#ff0000">YES</font> || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Can `TARGET=` links reposition unrelated targets?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font>^*^ || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Is setting `window.on*` properties possible across domains?</font> || YES (?) || YES (?) || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is setting `window.opener` possible across domains?</font> || YES || YES || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is setting `window.name` possible across domains?</font> || YES || YES || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is calling `frameElements` methods possible across domains?</font> || NO || NO || || YES || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is `postMessage` API supported?</font> || NO || NO || || NO || YES || NO || YES || NO || NO ||

^*^ In Chrome, this succeeds only if the both tabs share a common renderer process, which limits the scope of possible attacks.

===Privacy-related side channels===

As a consequence of cross-domain security controls being largely an afterthought, there is no strong compartmentalization and separation of browser-managed resource loading, cache, and metadata management for unrelated, previously visited sites - nor any specific protections that would prevent one site from exploiting these mechanisms to unilaterally and covertly collect fairly detailed information about user's general browsing habits.

Naturally, when the ability for `www.example-bank.com` to find out that their current visitor also frequents `www.example-casino.com` is not mitigated effectively, such a design runs afoul of user's expectations and may be a nuisance. Unfortunately, there is no good method to limit these risks without severely breaking backward compatibility, however.

Aside from coding vulnerabilities such as [http://code.google.com/p/doctype/wiki/ArticleScriptInclusion cross-site script inclusion], some of the most important browsing habit disclosure scenarios include:

  * *Reading back CSS `:visited` class on links:* cascading stylesheets support a number of [http://www.w3schools.com/CSS/css_pseudo_classes.asp pseudo-classes] that may be used by authors to define conditional visual appearance of certain elements. For hyperlinks, these pseudo-classes include `:link` (appearance of an unvisited link), `:hover` (used while mouse hovers over a link), `:active` (used while link is selected), and `:visited` (used on previously visited links).<p />Unfortunately, in conjunction with the previously described [http://blog.stchur.com/2006/06/21/css-computed-style/ getComputedStyle and currentStyle] APIs, which are designed to return current, composite CSS data for any given HTML element, this last pseudo-class allows any web site to examine which sites (or site sub-resources) of an arbitrarily large set were visited by the victim, and which were not: if the computed style of a link to `www.example.com` has `:visited` properties applied to it, there is a match.

  * *Full-body CSS theft:* as indicated in [#Cascading_stylesheets earlier sections], CSS parsers are generally very strict - but they fail softly: in case of any syntax errors, they do not give up, but rather attempt to locate the next valid declaration and resume parsing from there (this behavior is notably different from Javascript, which uses a more relaxed parser, but gives up on the first syntax error). This particular well-intentioned property permits a rogue third-party site to include any HTML page, such as `mbox.example-webmail.com`, as a faux stylesheet - and have the parser extract CSS definitions embedded on this page between `<STYLE>` and `</STYLE>` tags only, silently ignoring all the HTML in between.<p />Since many sites use very different inline stylesheets for logged in users and for guests, and quite a few services permit further page customizations to suit users' individual tastes - accessing the `getComputedStyle` or `currentStyle` after such an operation enables the attacker to make helpful observations about victim's habits on targeted sites.

  * *Resource inclusion probes with `onload` and `onerror` checks:* many of the sub-resource loading tags, such as `<IMG>`, `<SCRIPT>`, `<IFRAME>`, `<OBJECT>`, `<EMBED>`, or `<APPLET>`, will invoke `onload` or `onerror` handlers (if defined) to communicate the outcome of an attempt to load the requested URL.<p />Since it is a common practice for various sub-resources on complex web sites to become accessible only if the user is authenticated (returning HTTP 3xx or 4xx codes otherwise), the attacker may carry out rogue attempts to load assorted third-party URLs from within his page, and determine whether the victim is authenticated with cookies on any of the targeted sites.

  * *Image size fingerprinting:* a close relative of `onload` and `onerror` probing is the practice of querying `getComputedStyle` or `currentStyle` APIs on `<IMG>` containers with no dimensions specified by the page they appear on. A successful load of an authentication-requiring image would result in computed dimensions different from these used for a "broken image" stub.

  * *Document structure traversal:* most browsers permit pages to look up third-party named windows or `<IFRAME>` containers across domains. This has two important consequences in the context of user fingerprinting: one is that may be is possible to identify whether certain applications are open at the same time in other windows; the other is that by loading third-party applications in an `<IFRAME>` and trying to look up their sub-frames, if used, often allows the attacker to determine if the user is logged in with a particular site.<p />On top of that, some browsers also leak information across domains by throwing different errors if a property referenced across domains is not found, and different if found, but permission is denied. One such example is the `delete <win>.program_variable` operator.

  * *Cache timing:* many resources cached locally by the browser may, when requested, load in a couple milliseconds - whereas fetching them from the server may take a longer while. By timing `onload` events on elements such as `<IMG>` OR `<IFRAME>` with carefully chosen target URLS, a rogue page may tell if the requested resource, belonging to a probed site, is already cached - which would indicate prior visits - or not.<p />The probe works only once, as the resources probed this way would be cached for a while as a direct result of testing; but premature retesting could be avoided in a number of ways.

Assorted tests related to the aforementioned side channels:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is detection of `:visited` styles possible?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Can image sizes be read back?</font> || NO || NO || || YES || YES || YES || NO || YES || YES ||
|| <font color="#3050a0">Does CSS parser accept HTML documents as stylesheets?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Does `onerror` fire on all common HTTP errors?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is `delete <win>.var` probe possible?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || NO ||

<b></b>

==Various network-related restrictions==

On top of the odd mix of same-origin security policies and one-off exceptions to these rules, there is a set of very specific and narrow connection-related security rules implemented in browsers through the years to address various security flaws. This section provides an overview of these limitations.

===Local network / remote network divide===

The evolution of network security in the recent year resulted in an interesting phenomenon: many home and corporate networks now have very robust external perimeter defenses, filtering most of the incoming traffic in accordance with strict and well-audited access rules. On the flip side, the same networks still generally afford only weak and permissive security controls from within, so any local workstation may deal a considerable amount of damage.

Unfortunately for this model, browsers permit attacker-controlled Javascript or HTML to breach this boundary and take various constrained but still potentially dangerous actions from the network perspective of a local node. Because of this, it seems appropriate to further restrict the ability for such content to interact with any resources not meant to be visible to the outside world. In fact, not doing so already resulted in some otherwise avoidable and scary [http://jeremiahgrossman.blogspot.com/2008/04/intranet-hack-targeting-at-2wire-dsl.html real-world attacks].

That said, it is not trivial to determine what constitutes a protected asset on an internal network, and what is meant to be visible from the Internet. There are several proposed methods of approximating this set, however; possibilities include blocking access to:

  * Sites resolving to [http://www.faqs.org/rfcs/rfc1918.html RFC 1918] address spaces reserved for private use - as these are not intended to be routed publicly, and hence would never point to any meaningful resource on the Internet.

  * Sites not referenced through [http://en.wikipedia.org/wiki/FQDN fully-qualified domain names] - as addresses such as `http://intranet/` have no specific, fixed meaning to general public, but are extensively used on corporate networks.

  * Address and domain name patterns detected by other heuristics, such as IP ranges local to machine's network interfaces, DNS suffixes defined on proxy configuration exception lists, and so forth.

Because none of these methods is entirely bullet-proof or problem-free, as of now, a vast majority of browsers implements no protection against Internet → intranet fenceposts - although such mechanisms are being planned, tested, or offered optionally in response to previously demonstrated attacks. For example, Microsoft Internet Explorer 7 has a _"Websites in less privileged web content zone can navigate into this zone"_ setting that, if unchecked for _"Local intranet"_, would deny external sites access to a configurable subset of pages. The restriction is disabled by default, however.

Relevant tests:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is direct navigation to RFC 1918 IPs possible?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is navigation to non-qualified host names possible?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is navigation to names that resolve to RFC 1918 ranges possible?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||

<b></b>

===Port access restrictions===

As noted in [#Uniform_Resource_Locators earlier sections], URL structure technically permits an arbitrary, non-standard TCP port to be specified for any request. Unfortunately, this permitted attackers to trick browsers into meaningfully interacting with network services that do not really understand HTTP (particularly by abusing `ENCTYPE="text/plain"` forms, as [http://www.remote.org/jochen/sec/hfpa/index.html explained here]); these services would misinterpret the data submitted by the browser and could perform undesirable operations, such as accepting and routing SMTP traffic. Just as likely, said services could produce responses that would be in turn misunderstood to the browser, and trigger browser-side security flaws. A particularly interesting example of the latter problem - dubbed _same-site scripting_ - is discussed by Tavis Ormandy in [http://seclists.org/bugtraq/2008/Jan/0270.html this BUGTRAQ post].

Because of this, a rather arbitrary subset of ports belonging to common (and not so common) network services is in modern days blocked for HTTP and some other protocols in most browsers on the market:

|| <font color="#3050a0">*Browser*</font> || <font color="#3050a0">*Blocked ports*</font> ||
|| *MSIE6,* <br> *MSIE7* || 19 <font color="#909090">(chargen)</font>, 21 <font color="#909090">(ftp)</font>, 25 <font color="#909090">(smtp)</font>, 110 <font color="#909090">(pop3)</font>, 119 <font color="#909090">(nntp)</font>, 143 <font color="#909090">(imap2)</font> ||
|| *MSIE8* || ||
|| *Firefox,* <br> *Safari,* <br> *Opera,* <br> *Chrome* <br> *Android* || 1 <font color="#909090">(tcpmux)</font>, 7 <font color="#909090">(echo)</font>, 9 <font color="#909090">(discard)</font>, 11 <font color="#909090">(systat)</font>, 13 <font color="#909090">(daytime)</font>, 15 <font color="#909090">(netstat)</font>, 17 <font color="#909090">(qotd)</font>, 19 <font color="#909090">(chargen)</font>, 20 <font color="#909090">(ftp-data)</font>,21 <font color="#909090">(ftp)</font>, 22 <font color="#909090">(ssh)</font>, 23 <font color="#909090">(telnet)</font>, 25 <font color="#909090">(smtp)</font>, 37 <font color="#909090">(time)</font>, 42 <font color="#909090">(name)</font>, 43 <font color="#909090">(nicname)</font>, 53 <font color="#909090">(domain)</font>, 77 <font color="#909090">(priv-rjs)</font>, 79 <font color="#909090">(finger)</font>, 87 <font color="#909090">(ttylink)</font>, 95 <font color="#909090">(supdup)</font>, 101 <font color="#909090">(hostriame)</font>, 102 <font color="#909090">(iso-tsap)</font>, 103 <font color="#909090">(gppitnp)</font>, 104 <font color="#909090">(acr-nema)</font>, 109 <font color="#909090">(pop2)</font>, 110 <font color="#909090">(pop3)</font>, 111 <font color="#909090">(sunrpc)</font>, 113 <font color="#909090">(auth)</font>, 115 <font color="#909090">(sftp)</font>, 117 <font color="#909090">(uccp-path)</font>, 119 <font color="#909090">(nntp)</font>, 123 <font color="#909090">(ntp)</font>, 135 <font color="#909090">(loc-srv)</font>, 139 <font color="#909090">(netbios)</font>, 143 <font color="#909090">(imap2)</font>, 179 <font color="#909090">(bgp)</font>, 389 <font color="#909090">(ldap)</font>, 465 <font color="#909090">(ssl smtp)</font>, 512 <font color="#909090">(exec)</font>, 513 <font color="#909090">(login)</font>, 514 <font color="#909090">(shell)</font>, 515 <font color="#909090">(printer)</font>, 526 <font color="#909090">(tempo)</font>, 530 <font color="#909090">(courier)</font>, 531 <font color="#909090">(chat)</font>, 532 <font color="#909090">(netnews)</font>, 540 <font color="#909090">(uucp)</font>, 556 <font color="#909090">(remotefs)</font>, 563 <font color="#909090">(ssl nntp)</font>, 587 <font color="#909090">(smtp submission)</font>, 601 <font color="#909090">(syslog)</font>, 636 <font color="#909090">(ssl ldap)</font>, 993 <font color="#909090">(ssl imap)</font>, 995 <font color="#909090">(ssl pop3)</font>, 2049 <font color="#909090">(nfs)</font>, 4045 <font color="#909090">(lockd)</font>, 6000 <font color="#909090">(X11)</font> ||

There usually are various protocol-specific exceptions to these rules: for example, `ftp://` URLs are obviously permitted to access port 21, and `nntp://` may reference port 119. A detailed discussion of these exceptions in the prevailing Mozilla implementation is [http://www.mozilla.org/projects/netlib/PortBanning.html available here].

===URL scheme access rules===

The section on URL schemes notes that for certain URL types, browsers implement additional restrictions on what pages may use them and when. Whereas the rationale for doing so for special and dangerous schemes such as `res:` or `view-cache:` is rather obvious, the reasons for restricting two other protocols - most notably `file:` and `javascript:` - are more nuanced.

In the case of `file:`, web sites are generally prevented from navigating to local resources at all. The three explanations given for this decision are as follows:

  * Many browsers and browser plugins keep their temporary files and cache data in predictable locations on the disk. The attacker could first plant a HTML file in one these spots during normal browsing activities, and then attempt to open it by invoking a carefully crafted `file:///` URL. As noted earlier, many implementations of same-origin policies are eager to bestow special privileges on local HTML documents ([#Same-origin_policy_for_DOM_access more]), and so this led to frequent trouble.

  * Users were uncomfortable with random, untrusted sites opening local, sensitive files, directories, or applications within `<IFRAME>` containers, even if the web page embedding them technically had no way to read back the data - a property that a casual user could not verify.

  * Lastly, tags such as `<SCRIPT>` or `<LINK REL="stylesheet" HREF="...">` could be used to read back certain constrained formats of local files from the disk, and access the data from within cross-domain scripts. Although no particularly useful and universal attacks of this type were demonstrated, this posed a potential risk.

Browser behavior when handling `file:` URLs in Internet content is summed up in the following table:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Are `<IMG>` `file:` targets allowed to load?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">Are `<SCRIPT>` `file:` targets allowed to load?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">Are `<IFRAME>` `file:` targets allowed to load?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">Are `<EMBED>` `file:` targets allowed to load?</font> || NO || NO || || NO || NO || NO || NO || NO || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Are `<APPLET>` `file:` targets allowed to load?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Are stylesheet `file:` targets allowed to load?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || <font color="#909090">tbd</font> ||

_NOTE: For Microsoft Internet Explorer, the exact behavior for `file:` references is controlled by the "Websites in less privileged web content zone can navigate into this zone" setting for "My computer" zone._

The restrictions applied to `javascript:` are less drastic, and have a different justification. In the past, many HTML sanitizers implemented by various web applications could be easily circumvented by employing seemingly harmless tags such as `<IMG>`, but pointing their `SRC=` parameters to Javascript pseudo-URLs, instead of HTTP resources - leading to HTML injection and cross-site scripting. To make the life of web developers easier, a majority of browser vendors locked down many of the scenarios where a legitimate use of `javascript:` would be, in their opinion, unlikely:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Are `<IMG>` `javascript:` targets allowed to run?</font> || <font color="#ff0000">YES</font> || NO || || NO || NO || NO || <font color="#ff0000">YES</font> || NO || NO ||
|| <font color="#3050a0">Are `<SCRIPT>` `javascript:` targets allowed to run?</font> || <font color="#ff0000">YES</font> || NO || || NO || NO || NO || <font color="#ff0000">YES</font> || NO || NO ||
|| <font color="#3050a0">Are `<IFRAME>` `javascript:` targets allowed to run?</font> || YES || YES || || YES || NO || YES || YES || YES || YES ||
|| <font color="#3050a0">Are `<EMBED>` `javascript:` targets allowed to run?</font> || NO || NO || || NO || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Are `<APPLET>` `javascript:` targets allowed to run?</font> || NO || NO || || NO || <font color="#ff0000">YES</font> || NO || NO || NO || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Are stylesheet `javascript:` targets allowed to run?</font> || <font color="#ff0000">YES</font> || NO || || NO || NO || NO || <font color="#ff0000">YES</font> || NO || NO ||

<b></b>

===Redirection restrictions===

Similar to the checks placed on `javascript:` URLs in some HTML tags, HTTP `Location` and HTML `<META HTTP-EQUIV="Refresh" ...>` redirects carry certain additional security restrictions on pseudo-protocols such as `javascript:` or `data:` in most browsers. The reason for this is that it is not clear what security context should be associated with such target URLs. Sites that operate simple open redirectors for the purpose of recording click counts or providing interstitial warnings could fall prey to cross-site scripting attacks more easily if redirects to `javascript:` and other schemes that inherit their execution context from the calling content were permitted.

A survey of current implementations is documented below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is `Location` redirection to `file:` permitted?</font> || NO || NO || || NO || NO || NO || NO || NO || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">Is `Location` redirection to `javascript:` permitted?</font> || NO || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Is `Location` redirection to `data:` permitted?</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || || NO || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO ||
|| <font color="#3050a0">Is `Refresh` redirection to `file:` permitted?</font> || NO || NO || || NO || NO || NO || NO || NO || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">Is `Refresh` redirection to `javascript:` permitted?</font> || NO || NO || || NO || <font color="#ff0000">YES</font> || NO || NO || NO || NO ||
|| <font color="#3050a0">Is `Refresh` redirection to `data:` permitted?</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO ||
|| <font color="#3050a0">Same-origin XMLHttpRequest redirection permitted?</font> || YES || YES || || YES || YES || YES || YES || YES || NO ||

Redirection may also fail in a browser-specific manner on some other types of special requests, such as `/favicon.ico` lookups or `XMLHttpRequest`.

===International Domain Name checks===

The section on international domain names noted that certain additional security restrictions are also imposed on what characters may be used in IDN host names. The reason for these security measures stems from the realization that many Unicode characters are homoglyphs - that is, they look very much like other, different characters from the Unicode alphabet. For example, the following table shows several Cyrillic characters and their Latin counterparts with completely different UTF-8 codes:

|| <font color="#3050a0">*Latin*</font> || <font size="+1">a</font> || <font size="+1">c</font> || <font size="+1">e</font> || <font size="+1">h</font> || <font size="+1">i</font> || <font size="+1">j</font> || <font size="+1">o</font> || <font size="+1">p</font> || <font size="+1">s</font> || <font size="+1">x</font> || <font size="+1">y</font> ||
|| <font color="#3050a0">*Cyrillic*</font> || <font size="+1">a</font> || <font size="+1">c</font> || <font size="+1">e</font> || <font size="+1">h</font> || <font size="+1">i</font> || <font size="+1">j</font> || <font size="+1">o</font> || <font size="+1">p</font> || <font size="+1">s</font> || <font size="+1">x</font> || <font size="+1">y</font> ||

Because of this, with unconstrained IDN support in effect, attacker could easily register www.ex<font color="#ff0000">a</font>mple.com (Cyrillic character shown in red), and trick his victims into believing they are on the real and original www.ex<font color="#3050a0">a</font>mple.com site (all Latin). Although "weak" homograph attacks were known before - e.g., www.examp<font color="#3050a0">l</font>e.com and www.examp<font color="#ff0000">1</font>e.com or www.exa<font color="#ff0000">rn</font>ple.com may look very similar in many typefaces - IDN permitted a wholly new level of domain system abuse.

For a short while, until the first reports [http://www.cs.technion.ac.il/~gabr/papers/homograph_full.pdf pointing out the weakness] came in, the registrars apparently assumed that browsers would be capable of detecting such attacks - and browser vendors assumed that it is the job of registrars to properly screen registrations. Even today, there is no particularly good solution to IDN homoglyph attacks available at this time. In general, browsers tend to implement one of the following strategies:

  * Not doing anything about the problem, and just displaying Unicode IDN as-is. This is the case for the tested version of Opera.

  * Reverting to Punycode notation when characters in a script not matching user's language settings appear in URLs. This practice is followed by Microsoft Internet Explorer ([http://msdn.microsoft.com/en-us/library/bb250505.aspx vendor information]) and Safari ([http://support.apple.com/kb/TA22996?viewlocale=en_US vendor information]). The approach is not bulletproof - as users with certain non-Latin scripts configured may be still easily duped - and tends to cause problems in legitimate uses.

  * Reverting to Punycode on all domains with the exception of a whitelisted set, where the registrars are believed to be implementing robust anti-phishing measures. The practice is followed by Firefox ([http://www.viagenie.ca/publications/2007-03-apricot-using-idn-firefox-blanchet.pdf more details]). Additionally, as a protection against IDN characters that have no legitimate use in domain names in any script (e.g., www.example-bank.com<font color="#ff0000">⁄</font>fuzzy-bunnies.ch), a short blacklist of characters is also incorporated into the browser. A general problem with this approach is that it is very difficult to accurately and exhaustively asses actual implementations of phishing countermeasures implemented by hundreds of registrars, and then keep the list up to date; another major issue is that it rules out any use of IDN in TLDs such as .com.

  * Displaying Punycode at all times. This option, currently implemented by Chrome, ensures the purity of traditional all-Latin domain names. On the flip side, the approach penalizes users who interact with legitimate IDN sites on a daily basis, as they have to accurately differentiate between non-human-readable host name strings to spot phishing attempts against said sites.

Experimental solutions to the problem that could potentially offer better security, including color-coding IDN characters in domain names, or employing homoglyph-aware domain name cache to minimize the risk of spoofing against any sites the user regularly visits, were discussed previously, but none of them gained widespread support.

===Simultaneous connection limits===

For performance reasons, most browsers regularly issue requests simultaneously, by opening multiple TCP connections. To prevent overloading servers with excessive traffic, and to minimize the risk of abuse, the number of connections to the same target is usually capped. The following table captures these limits, as well as default read timeouts for network resources:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Maximum number of same-origin connections</font> || 4 || 4 || || 2 || 6 || 4 || 4 || 6 || 4 ||
|| <font color="#3050a0">Network read timeout</font> || 5 min || 5 min || || 5 min || 10 min || 1 min || 5 min || 5 min || 2 min ||

<b></b>

==Third-party cookie rules==

Another interesting security control built on top of the existing mechanisms is the concept of restricting third-party cookies. For the privacy reasons [#Same-origin_policy_for_cookies noted earlier], there appeared to be a demand for a seemingly simple improvement: restricting the ability for any domain other than the top-level one displayed in the URL bar, to set cookies while a page is being visited. This was to prevent third-party content (advertisements, etc) included via `<IMG>`, `<IFRAME>`, `<SCRIPT>`, and similar tags, from setting tracking cookies that could identify the user across unrelated sites relying on the same ad technology.

A setting to disable third-party cookies is available in many browsers, and in several of them, the option is enabled by default. Microsoft Internet Explorer is a particularly interesting case: it rejects third-party cookies with the default "automatic" setting, but permits sites to override this behavior by declaring a proper, user-friendly intent through [http://www.w3.org/P3P/P3FAQ.html compact P3P privacy policy headers] (a mechanism discussed in more detail [http://www.oreillynet.com/pub/a/network/excerpt/p3p/p3p.html here] and [http://www.oreillynet.com/pub/a/network/excerpt/p3p/p3p.html here]). If a site specifies a privacy policy and the policy implies that personally identifiable information is not collected (e.g., `P3P: CP=NOI NID NOR`), on default security settings, session cookies are permitted to go through regardless of third-party cookie security settings. 

The purpose of this design is to force legitimate businesses to make a (hopefully) binding legal statement through this mechanism, so that violations could be prosecuted. Sadly, the approach has the unfortunate property of being a legislative solution to a technical problem, bestowing potential liability at site owners who often simply copy-and-paste `P3P` header examples from the web without understanding their intended meaning; the mechanism also does nothing to stop shady web sites from making arbitrary claims in these HTTP headers and betting on the mechanism never being tested in court - or even simply [http://www.interesting-people.org/archives/interesting-people/200112/msg00196.html disavowing any responsibility] for untrue, self-contradictory, or nonsensical P3P policies.

The question of what constitues "first-party" domains introduces a yet another, incompatible same-origin check, called [http://msdn.microsoft.com/en-us/library/ms537343(VS.85).aspx#first_and_third_party_context minimal domains]. The idea is that `www1.eu.example.com` and `www2.us.example.com` should be considered first-party, which is not true for all the remaining same-origin logic in other places. Unfortunately, these implementations are generally even more buggy than cookies for country-code TLDs: for example, in Safari, `test1.example.cc` and `test2.example.cc` are _not_ the same minimal domain, while in Internet Explorer, `domain1.waw.pl` and `domain2.waw.pl` are.

Although any third-party cookie restrictions are not a sufficient method to prevent cross-domain user tracking, they prove to be rather efficient in disrupting or impacting the security of some legitimate web site features, most notably certain web gadgets and authentication mechanisms.

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Are restrictions on third-party cookies on in default config?</font> || YES || YES || || NO || NO || YES || NO || NO || NO ||
|| <font color="#3050a0">Option to change third-party cookie handling?</font> || YES || YES || || NO || YES || YES || persistent only || NO || NO ||
|| <font color="#3050a0">Is P3P policy override supported?</font> || YES || YES || || <font color="#909090">n/a</font> || NO || NO || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> ||
|| <font color="#3050a0">Are third-party cookies permitted within same domain?</font> || YES || YES || || <font color="#909090">n/a</font> || YES || YES || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> || 
|| <font color="#3050a0">Behavior of minimal domains in ccTLDs (3 tests)</font> || <font color="#ff0000">1/3 FAIL</font> || <font color="#ff0000">1/3 FAIL</font> || || <font  color="#909090">n/a</font> || 3/3 PASS || <font color="#ff0000">1/3 FAIL</font> || <font  color="#909090">n/a</font> || <font color="#909090">n/a</font> || <font color="#909090">n/a</font> ||

<b></b>

==Content handling mechanisms==

===Survey of content sniffing behaviors===

===Downloads and Content-Disposition===

===Character set handling and detection===

===Document caching===

==Defenses against disruptive scripts==

===Popup and dialog filtering logic===

===Window appearance restrictions===

===Execution timeouts and memory limits===

===Page transition logic===

==Protocol-level encryption facilities==

=Experimental and legacy security mechanisms=

==HTTP authentication==

==Microsoft Internet Explorer zone model==

==Microsoft Internet Explorer frame restrictions==

==Microsoft Internet Explorer XSS filtering==

==Script restriction frameworks==

==Origin headers==

==Mozilla content security policies==

=Open browser engineering issues=

=Acknowledgments=