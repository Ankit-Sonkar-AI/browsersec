#summary Main wiki page
#labels Featured

<h1>Browser Security Handbook</h1>

  * Written and maintained by [http://lcamtuf.coredump.cx/ Michal Zalewski] <[mailto:lcamtuf@google.com lcamtuf@google.com]>. 
  * Copyright 2008 Google Inc, rights reserved.
  * Released under terms and conditions of the [http://creativecommons.org/licenses/by/3.0 CC-3.0-BY] license.

<h1>Table of Contents</h1>

=Introduction=

Hello, and welcome to _Browser Security Handbook_!

Browser Security Handbook is meant to provide web application developers, browser engineers, and information security researchers with a one-stop reference to key security properties of contemporary web browsers. Insufficient understanding of these often poorly-documented characteristics is a major contributing factor to the prevalence of several classes of security vulnerabilities.

Although all browsers implement roughly the same set of baseline features, there is relatively little conformance to standards when it comes to many of the less apparent characteristics. Furthermore, vendors routinely introduce poorly documented, proprietary tweaks or improvements that may interfere with existing features in non-obvious ways. For these reasons, it seemed prudent to compile this reference.

The current version of this document is based on the following versions of web browsers:

|| <font color="#3050a0">*Browser*</font> || <font color="#3050a0">*Version*</font> || <font color="#3050a0">*Test date*</font> || <font color="#3050a0">*Notes*</font> ||
|| Microsoft Internet Explorer 6 || 6.0.2900.5512 || Nov 18, 2008 || ||
|| Microsoft Internet Explorer 7 || 7.0.5730.11 || Nov 18, 2008 || ||
|| <font color="#909090">Microsoft Internet Explorer 8 (beta)</font> || || || <font color="#909090">Not tested - pending stabilization.</font> ||
|| Mozilla Firefox 2 || 2.0.0.17 || Nov 6, 2008 || ||
|| Mozilla Firefox 3 || 3.0.3 || Nov 18, 2008 || ||
|| Apple Safari || 3.2 || Nov 18, 2008 || ||
|| Opera || 9.62 || Nov 18, 2008 || ||
|| Google Chrome || 0.3.154.9 || Nov 18, 2008 || ||
|| Android  built-in browser || SDK 1.0 RC1 || Nov 10, 2008 || Tests requiring `file:///` targets not executed. ||

*DISCLAIMER: Although we tried to make this document as accurate as possible, some errors might have slipped through. Please use this document only as an initial reference, and independently verify any characteristics you wish to depend upon. All the test cases featured in this document are [http://browsersec.googlecode.com/files/browser_tests-1.0.tar.gz freely available for download].*

=Underlying technologies=

This section provides a review of core standards and technologies behind modern browsers, and their security-relevant properties. No specific attention is given to features implemented explicitly for security purposes; these are discussed in later in the document.

==Uniform Resource Locators==

All web resources are addressed with the use of uniform resource identifiers. Being able to properly parse the format, and make certain assumptions about the data present therein, is of significance to many server-side security mechanisms.

The abstract syntax for URIs is described in [http://www.ietf.org/rfc/rfc3986.txt RFC 3986]. The document defines a basic hierarchical URI structure, defining a white list of unreserved characters that may appear in URIs as-is as element names, with no particular significance assigned (`0-9 A-Z a-z - . _ ~`), spelling out reserved characters that have special meanings and can be used as-is only in their desired function (`: / ? # [ ] @ ! $ & ' ( ) * + , ; =`), and establishing a hexadecimal percent-denoted encoding (`%nn`) for everything outside these sets (including the stray `%` character itself).

Some additional mechanisms are laid out in [http://www.ietf.org/rfc/rfc1738.txt RFC 1738], which defines URI syntax within the scope of HTTP, FTP, NNTP, Gopher, and several other specific protocols. Together, these RFCs define the following syntax for common Internet resources (the compliance with a generic naming strategy is denoted by the `//` prefix):

{{{
scheme://[authority[:password]@](host_name|\[host_address\])[:port][/hierarchical/path/to/resource[?search_string][#fragment_id]]
}}}

Since the presence of a scheme is the key differentiator between relative references permitted in documents for usability reasons, and fully-qualified URLs, and since `:` itself has other uses later in the URL, the set of characters permitted for scheme name must be narrow and clearly defined (`0-9 A-Z a-z + - .`) so that all implementations may make the distinction accurately.

On top of the aforementioned documents, a W3C draft [http://www.w3.org/Addressing/rfc1630.txt RFC 1630] outlines some additional concepts, such as the exact HTTP search string syntax (`param1=val1[&param2=val2&...]`), or the ability to use the `+` sign as a shorthand notation for spaces (the character itself does not function in this capacity elsewhere in the URL, which is somewhat counterintuitive).

In practice, browsers deviate from these standards in many ways, for example accepting URLs with technically forbidden, and then trying to escape them automatically; or applying heuristics to handle incomplete or seemingly broken URLs. Here are some of the key differences that often need to be accounted for:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| Non-standard characters permitted in URL scheme fields (excluding `0-9 A-Z a-z + - .`) || \t \r \n || \t \r \n || || \t \r \n || \t \r \n || <font color="#909090">none</font> || \r \n <font color="#ff0000">+UTF8</font> || <font color="#ff0000">\0</font> \t \r \n || <font color="#909090">none</font> ||
|| Non-standard characters kept as-is, with no escaping, in URL queries (excluding `0-9 A-Z a-z - . _ ~ : / ? # [ ] @ ! $ & ' ( ) * + , ; =`) || <font color="#ff0000">" < > \</font> ^ ` { | } \x7F || <font color="#ff0000">" < > \</font> ^ ` { | } \x7F || || <font color="#ff0000">\</font> ^ { | } || <font color="#ff0000">\</font> ^ { | } || ^ { | } || ^ { | } \x7F || <font color="#ff0000">" \</font> ^ ` { | } || <font color="#909090">tbd</font> ||
|| Non-standard characters fully ignored in host names || \t \r \n || \t \r \n \xAD || || \t \r \n \xAD || \t \r \n \xAD || \xAD || \x0A-\x0D \xA0 \xAD || \t \r \n \xAD || <font color="#909090">none</font> ||
|| Types of partial or broken URLs auto-corrected to fully qualified ones || //y \\y || //y \\y || || //y x:///y x://`[y]` || //y x:///y x://`[y]` || //y \\y x:/y x:///y || //y \\y x://`[y]` || //y \\y x:///y || //y \\y ||
|| Fragment ID (hash) encoded by applying RFC-mandated URL escaping rules? || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || || <font color="#ff0000">PARTLY</font> || <font color="#ff0000">PARTLY</font> || YES || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || YES ||

_NOTE: As an anti-phishing mechanism, additional restrictions on the use of `authority` and `password` fields in URLs are imposed by many browsers; see the section on HTTP authentication later on._

Please note that when links are embedded within HTML documents, [http://www.w3.org/TR/REC-html40/charset.html#h-5.3.2 HTML entity decoding] takes place before the link is parsed. Because of this, if a newline is ignored in URL schemes, a link such as `javascript&#09;:alert(1)` may be accepted and executed as Javascript, just as `javascript<TAB>:alert(1)` would be.

==Unicode in URLs==

Much like several related technologies used for web content transport, URLs do not have any particular character set defined by relevant RFCs; [http://www.ietf.org/rfc/rfc3986.txt RFC 3986] ambiguously states: _"In local or regional contexts and with improving technology, users might benefit from being able to use a wider range of characters; such use is not defined by this specification."_ The same dismissive approach is taken in HTTP header specification.

As a result, in the context of web URLs, any high-bit user input may and should be escaped as `%nn` sequences, but there is no specific guidance provided on how to transcode user input in system's native code page when talking to other parties that may not share this code page. On a system that uses UTF-8 and receives an URL containing Unicode `Ä…` in the path, this corresponds to a sequence of `0xC4 0x85` natively; however, when sent to a server that uses `ISO-8859-2`, the correct value sent should be `0xB1` (or alternatively, additional information about client-specific encoding should be included to make the conversion possible on server side). In practice, most browsers deal with this by sending UTF-8 data by default on any text entered in the URL bar by hand, and using page encoding on all followed links.

Another limitation of URLs traces back to DNS as such; [http://www.ietf.org/rfc/rfc1035.txt RFC 1035] permits only characters `A-Z a-z 0-9 -` in DNS labels, with period (`.`) used as a delimiter; some resolver implementations further permit underscore (`_`) to appear in DNS names, violating the standard, but other characters are almost universally banned. With the growth of the Web, the need to accommodate non-Latin alphabets in host names was perceived by multiple parties - and the use of `%nn` encoding was not an option, because `%` as such was not on the list.

To solve this, [http://tools.ietf.org/html/rfc3490 RFC 3490] lays out a rather contrived encoding scheme that permitted Unicode data to be stored in DNS labels, and [http://tools.ietf.org/html/rfc3492 RFC 3492] outlines a specific implementation within DNS labels - commonly referred to as Punycode - that follows the notation of `xn--[US-ASCII part]-[encoded Unicode data]`. Any Punycode-aware browser faced with non US-ASCII data in a host name is expected to transform it to this notation first, and then perform a traditional DNS lookup for the encoded string.

Putting these two methods together, the following transformation is expected to be made internally by the browser:

{{{
http://www.rÄ™czniki.pl/?rÄ™cznik=1 â†’ http://www.xn--rczniki-98a.pl/?r%C4%99cznik=1
}}}

Key security-relevant differences in high-bit URL handling are outlined below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| Request URL path encoding when following plain links || UTF-8 || UTF-8 || || page encoding || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 ||
|| Request URL query string encoding when following plain links || <font color="#ff0000">page encoding, no escaping</font> || <font color="#ff0000">page encoding, no escaping</font> || || page encoding || page encoding || page encoding || page encoding || page encoding || page encoding ||
|| Request URL path encoding for `XMLHttpRequest` calls || page encoding || page encoding || || page encoding || page encoding || page encoding || page encoding || page encoding || page encoding ||
|| Request URL query string encoding for `XMLHttpRequest` calls || <font color="#ff0000">page encoding, no escaping</font> || <font color="#ff0000">page encoding, no escaping</font> || || page encoding || page encoding || <font color="#ff0000">mangled</font> || page encoding || <font color="#ff0000">mangled</font> || <font color="#ff0000">mangled</font> || 
|| Request URL path encoding for manually entered URLs || UTF-8 || UTF-8 || || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 ||
|| Request URL query string encoding for manually entered URLs || <font color="#ff0000">transcoded to 7 bit</font> || <font color="#ff0000">transcoded to 7-bit</font> || || UTF-8 || UTF-8 || UTF-8 || <font color="#ff0000">stripped to `?`</font> || UTF-8 || UTF-8 ||
|| Raw Unicode in host names auto-converted to Punycode? || NO || YES || || YES || YES || YES || YES || YES || NO ||
|| Percent-escaped UTF-8 in host names auto-converted to Punycode? || (NO) || YES || || <font color="#ff0000">NO</font> || <font color="#ff0000">on retry</font> || YES || YES || YES || (NO) ||
|| URL bar Unicode display method for host names || (Punycode) || Unicode || || Unicode || Unicode || Unicode || Unicode || Punycode || (Punycode) ||
|| URL bar Unicode display method outside host names || Unicode || Unicode || || `%nn` || Unicode || Unicode || as `?` || Unicode || <font color="#909090">n/a</font> ||

 
_NOTE: As an anti-phishing mechanism, additional restrictions on the use of some or all Unicode characters in certain top-level domains are imposed by many browsers; see domain name restrictions chapter later on._

==True URL schemes==

URL schemes are used to indicate what general protocol needs to be used to retrieve the data, and how the information needs to be processed for display. Schemes may also be tied to specific default values of some URL fields - such as a TCP port - or specific non-standard URL syntax parsing rules (the latter is usually denoted by the absence of a `//` string after scheme identifier).

Back in 1994, [http://www.ietf.org/rfc/rfc1738.txt RFC 1738] laid out several URL schemes in the context of web browsing, some of which are not handled natively by browsers, or have fallen into disuse. As the Web matured, multiple new open and proprietary schemes appeared with little or no consistency, and the set of protocols supported by each browser began to diverge. [http://www.ietf.org/rfc/rfc2718.txt RFC 2718] attempted to specify some ground rules for the creation of new protocols, and [http://www.ietf.org/rfc/rfc4395.txt RFC 4395] mandated that new schemes be registered with IANA (their list is [http://www.iana.org/assignments/uri-schemes.html available here]). In practice, however, few parties could be bothered to follow this route.

To broadly survey the capabilities of modern browsers, it makes sense to divide URL schemes into a group natively supported by the software, and another group supported by a plethora of plugins, extensions, or third-party programs. The first list is relatively short:

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| HTTP ([http://www.ietf.org/rfc/rfc2616.txt RFC 2616]) || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| HTTPS ([http://www.ietf.org/rfc/rfc2616.txt RFC 2818]) || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| SHTTP ([http://www.ietf.org/rfc/rfc2660.txt RFC 2660]) || as HTTP || as HTTP || || NO || NO || NO || NO || NO || NO ||
|| FTP ([http://www.ietf.org/rfc/rfc1738.txt RFC 1738]) || YES || YES || || YES || YES || YES || YES || YES || NO ||
|| file ([http://www.ietf.org/rfc/rfc1738.txt RFC 1738]) || YES || YES || || YES (local) || YES (local) || YES (local) || YES || YES || _tbd_ ||
|| Gopher ([http://www.ietf.org/rfc/rfc14266.txt RFC 4266]) || NO || NO || || YES || YES || NO || defunct? || NO || NO ||
|| news ([http://tools.ietf.org/html/draft-ellermann-news-nntp-uri-11 draft RFC]) || NO || NO || || NO || NO || NO || YES || NO || NO ||

These protocols may be used to deliver natively rendered content that is interpreted and executed using the security rules implemented within the browsers.

The other list, third-party protocols routed to other applications, depends quite heavily on system configuration. The set of protocols and their handlers is usually maintained in a separate system-wide registry. Browsers may whitelist some of them by default (executing external programs without prompting), or blacklist some (preventing their use altogether); the default action is often to display a mildly confusing prompt. Most common protocols in this family include:

{{{
acrobat                           - Acrobat Reader
callto                            - some instant messengers, IP phones
daap / itpc / itms / ...          - Apple iTunes
FirefoxURL                        - Mozilla Firefox
hcp                               - Microsoft Windows Help subsystem
ldap                              - address book functionality
mailto                            - various mail agents
mmst / mmsu / msbd / rtsp / ...   - streaming media of all sorts
mso-offdap                        - Microsoft Office
news / snews / nntp               - various news clients
outlook / stssync                 - Microsoft Outlook
rlogin / telnet / tn3270          - telnet client
shell                             - Windows Explorer
sip                               - various IP phone software
}}}

New handlers might be registered in OS- and application-specific ways, for example by registering new `HKCR\Protocols\Handlers` keys in Windows registry, or adding `network.protocol-handler.*` settings in Firefox.

As a rule, the latter set of protocols is not honored within the renderer when referencing document elements such as images, script or applet sources, and so forth; they do work, however, as `IFRAME` and link targets, and will launch a separate program as needed. These programs may sometimes integrate seamlessly with the renderer, but the rules by which they render content and impose security restrictions are generally unrelated to the browser as such.

Historically, the ability to plant such third-party schemes in links proved to be a significant exploitation vector, as poorly written, vulnerable external programs often register protocol handlers without user's knowledge or consent; as such, it is prudent to reject unexpected schemes where possible, and exercise caution when introducing new ones on client side (including observing [http://www.securityfocus.com/bid/24837/ safe parameter passing conventions]).

==Pseudo URL schemes==

In addition to the aforementioned "true" URL schemes, modern browsers support a large number of pseudo-schemes used to implement various advanced features, such as encapsulating encoded documents within URLs, providing legacy scripting features, or giving access to internal browser information and data views.

Encapsulating schemes are of interest to any link-handling applications, as these methods usually impose specific non-standard content parsing or rendering modes on top of existing resources specified in the later part of the URL. The underlying content is retrieved using HTTP, looked up locally (e.g., `file:///`), or obtained using other generic method - and may execute in the security context associated with the true origin of data. For example, the following URL:

{{{
jar:http://www.example.com/archive.jar!/resource.html
}}}

...will be retrieved over HTTP from `http://www.example.com/archive.jar`. Because of the encapsulating protocol, the browser will then attempt to interpret the obtained file as a standard Sun Java ZIP archive (`JAR`), and extract, then display `/resource.html` from within that archive.

Common encapsulating schemes are shown in the table below.

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| feed (RSS, [http://www.brindys.com/winrss/feedformat.html draft spec]) || NO || NO || || NO || NO || YES || NO || NO || NO ||
|| hcp, its, mhtml, mk, ms-help, ms-its, ms-itss (Windows Help archive parsing) || YES || YES || || NO || NO || NO || NO || NO || NO ||
|| jar ([http://docs.sun.com/source/819-0913/author/jar.html Java archive parsing]) || NO || NO || || YES || YES || NO || NO || NO || NO ||
|| view-cache, wyciwyg (cached page views) || NO || NO || || YES || YES || NO || NO || YES || NO ||
|| view-source (page source views) || NO || NO || || YES || YES || NO || NO || YES || NO ||

In addition to encapsulating schemes enumerated above, there are various schemes used for accessing browser-specific internal features unrelated to web content. These pseudo-protocols include `about:` (used to access static info pages, errors, cache statistics, configuration pages, [http://en.wikipedia.org/wiki/About: and more]), `moz-icon:` (used to access file icons), `chrome:`, `chrome-resource:`, `chromewebdata:`, `resource:`, `res:`, `rdf:`, and `inspector:` (all used to reference built-in resources of the browser, often rendered with elevated privileges). There is little or no standardization or proper documentation for these mechanisms, but as a general rule, web content is not permitted to directly reference any sensitive data. Permitting them to go through on trusted pages may serve as an attack vector in case of browser-side vulnerabilities, however.

Finally, several pseudo-schemes exist specifically to enable scripting or URL-contained data rendering in the security context inherited from the caller, without actually referencing any additional external or internal content. It is particularly unsafe to output attacker-controlled URLs of this type on pages that may contain any sensitive content. Known schemes of this type include:

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| data ([http://www.ietf.org/rfc/rfc2397.txt RFC 2397]) || NO || NO || || YES || YES || YES || YES || YES || YES ||
|| javascript ([http://developer.mozilla.org/en/docs/JavaScript scripting]) || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| vbscript ([http://msdn.microsoft.com/en-us/library/sx7b3k7y(VS.85).aspx scripting]) || YES || YES || || NO || NO || NO || NO || NO || NO ||


_NOTE: Historically, numerous aliases for these schemes were also present; `livescript` and `mocha` schemes were supported by Netscape Navigator and other early browsers as aliases for Javascript; `local` worked in some browsers as a nickname for `file`; etc. This is generally not seen anymore._

==Hypertext Transfer Protocol==

The core protocol used to request and annotate much of web traffic is called the Hypertext Transfer Protocol. This text-based scheme originated as a very simple, underspecified design drafted by Tim Berners-Lee, and dubbed HTTP/0.9 ([http://www.w3.org/Protocols/HTTP/AsImplemented.html see W3C archive]) - these days no longer used by web browsers, but recognized by some servers. It then evolved into a fairly complex, and still somewhat underspecified HTTP/1.1, as described in [http://www.ietf.org/rfc/rfc2616.txt RFC 2616], whilst maintaining some superficial backward compatibility with the original idea.

Every HTTP request opens with a single-line description of a content access method (`GET` meant for requesting basic content, and `POST` meant for submitting state-changing data to servers - along with plethora of more specialized options typically not used by web browsers under normal circumstances). In HTTP/1.0 and up, this is then followed by protocol version specification - and the opening line itself is followed by zero or more additional `field: value` headers, each occupying their own line. These headers specify all sorts of meta-data, from target host name (so that a single machine may host multiple web sites), to information about client-supported MIME types, cache parameters, the site from which a particular request originated (`Referer`), and so forth. Headers are terminated with a single empty line, followed by any optional payload data being sent to the server if specified by a `Content-Length` header. 

One example of an HTTP request might be:

{{{
POST /fuzzy_bunnies/images/bunny_dispenser.php HTTP/1.1
Host: www.fuzzybunnies.com
User-Agent: Bunny Browser 1.7
Content-Type: text/plain
Content-Length: 11
Referer: http://www.fuzzybunnies.com/main.html

HELLO SERVER
}}}

The server responds in a similar manner, returning a numerical status code, spoken protocol version, and similarly formatted metadata headers followed by actual content requested, if available:

{{{
HTTP/1.1 200 OK
Server: Bunny Server 0.9.2
Content-Type: text/plain

HELLO CLIENT
}}}

Originally, every connection would be one-shot: after a request is sent, and response received, the session is terminated, and a new connection needs to be established. Since the need to carry out a complete TCP/IP handshake for every request imposed a performance penalty, newer specifications introduced the concept of keep-alive connections, negotiated with a particular request header that is then acknowledged by the server.

This, in conjunction with the fact that HTTP supports proxying and content caching on interim systems managed by content providers, ISPs, and individual subscribers, made it particularly important for all parties involved in an HTTP transaction to have exactly the same idea of where a request starts, where it ends, and what it is related to. Unfortunately, the protocol itself is highly ambiguous and has a potential for redundancy, which leads to multiple problems and differences between how servers, clients, and proxies may interpret responses:

  * Like many other text protocols of that time, early takes on HTTP made little or no effort to mandate a strict adherence to a particular understanding of what a text-based format really is, or how certain "intuitive" field values must be structured. Because of this, implementations would recognize, and often handle in incompatible ways, technically malformed inputs - such as incorrect newline characters (lone `CR`, lone `LF`, `LF CR`), `NUL` or other disruptive control characters in text, incorrect number of whitespaces in field delimiters, and so forth; to various implementations, `Head\0er: Value` may appear as `Head`, `Head: Value`, `Header: Value`, or `Head\0er: Value`. In later versions, as outlined in RFC 2616 section 19.3 ("Tolerant Applications"), the standard explicitly recommends, but does not require, lax parsing of certain fields and invalid values. One of the most striking examples of compatibility kludges is Firefox [http://mxr.mozilla.org/mozilla1.8.0/source/nsprpub/pr/src/misc/prtime.c#1045 prtime.c] function used to parse HTTP `Date` fields, which shows a stunning complexity behind what should be a remarkably simple task.

  * No particular high bit character set is defined for HTTP headers, and high bit characters are technically disallowed, despite legitimate reasons for them to appear in certain HTTP fields (e.g., `Cookie`, `Content-Disposition` filenames), and the protocol having no provisions for any particular method of escaping them. This resulted in some implementations interpreting HTTP data as UTF-8, and some using single-byte interpretations native to low-level OS string handling facilities.

   * The behavior when some headers critical to the correct understanding of an HTTP request are duplicate or contradictory is not well defined; as such, various clients will give precedence to different occurrences of the same parameter within HTTP headers (e.g., duplicate `Content-Type`), or assign various weights to conflicting information (say, `Content-Length` not matching payload length).

   * When new features that change the meaning of requests were introduced in HTTP/1.1 standard, no strict prohibition against recognizing them in requests or responses marked as HTTP/1.0 was made. As a result, the understanding of HTTP/1.0 traffic may differ significantly between legacy agents, such as some commercial web proxies, and HTTP/1.1 applications such as contemporary browsers (e.g., `Connection: keep-alive`, `Transfer-Encoding: chunked`, `Accept-Encoding: ...`).

Many specific areas, such as caching behavior, have their own sections later in this document. Below is a survey of general security-relevant differences in HTTP protocol implementations:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| `Content-Length` header value overrides actual content length? || NO || YES || || NO || NO || YES || YES || NO || YES ||
|| First HTTP header of the same name takes precedence? || YES || YES || || NO || NO || YES || NO || NO || NO ||
|| First field value in a HTTP header takes precedence? || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| `Referer` header disclosed on HTTPS â†’ HTTPS navigation? || YES || YES || || YES || YES || YES || NO || YES || YES ||
|| `Referer` header disclosed on HTTPS â†’ HTTP navigation? || NO || NO || || NO || NO || NO || NO || NO || NO ||
|| Response body on invalid 30x redirect shown to user? || NO || NO || || YES || YES || NO || YES || YES || broken ||

==Hypertext Markup Language==

Hypertext Markup Language, the primary document format rendered by modern web browsers, has its roots with [http://en.wikipedia.org/wiki/SGML Standard Generalized Markup Language], a standard for machine-readable documents. The initial [http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html HTML draft] provided a very limited syntax intended strictly to define various functional parts of the document. With the rapid development of web browsers, this basic technology got extended very rapidly and with little oversight to provide additional features related to visual presentation, scripting, and various perplexing and proprietary bells and whistles. Perhaps more interestingly, the format was also extended to provide the ability to embed other, non-HTTP multimedia content on pages, nest HTML documents within frames, and submit complex data structures and client-supplied files.

The mess eventually led to a post-factum compromise standard dubbed [http://www.w3.org/TR/REC-html32 HTML 3.2]. The outcome of this explosive growth was a format needlessly hard to parse, and combining unique quirks, weird limitations, and deeply intertwined visual style and document structure information - and so ever since, W3C and WHATWG focused on making HTML a clean, strict, and well-defined language, a goal at least approximated with [http://www.w3.org/TR/html401/ HTML 4] and [[http://www.w3.org/TR/xhtml2/ XHTML]] (a variant of HTML that strictly conforms to XML syntax rules), as well as the ongoing work on [[http://www.w3.org/TR/html5/ HTML 5]].

This day, the four prevailing HTML document rendering implementations are:

  * [http://msdn.microsoft.com/en-us/library/aa741317.aspx Trident] (MSHTML) - used in MSIE6, MSIE7, MSIE8,
  * [http://developer.mozilla.org/en/Gecko Gecko] - used in Firefox and derivates,
  * [http://webkit.org/ WebKit] - used by Safari, Chrome, Android,
  * Presto - used in Opera.

The ability for various applications to accurately understand HTML document structure, as it would be seen by a browser, is an important security challenge. The serial nature of the HTML blends together code (Javascript, Flash, Java applets) and the actual data to be displayed - making it easy for attackers to smuggle dangerous directives along with useful layout information in any external content. Knowing exactly what is being rendered is often crucial to site security (see [http://code.google.com/p/doctype/wiki/ArticleXSS this article] for a broader discussion of the threat).

Sadly, for compatibility reasons, parsers operating in non-XML mode tend are generally remarkably lax and feature proprietary, incompatible, poorly documented recovery modes that make it very difficult for any platform to anticipate how a third-party HTML document would be interpreted. Any of the following grossly malformed examples may be interpreted as a scripting directive by some, but usually not all, renderers:

{{{
1: <B <SCRIPT>alert(1)</SCRIPT>>
2: <B="<SCRIPT>alert(1)</SCRIPT>">
3: <IMG SRC=`javascript:alert(1)`>
4: <S[0x00]CRIPT>alert(1)</S[0x00]CRIPT>
5: <A """><IMG SRC="javascript:alert(1)">
6: <IMG onmouseover =alert(1)>
7: <A/HREF="javascript:alert(1)">
8: <!-- Hello -- world > <SCRIPT>alert(1)</SCRIPT> -->
}}}

Cross-site scripting aside, another interesting property of HTML is that it permits certain HTTP directives to be encoded within HTML itself, using the following format:

{{{
<META HTTP-EQUIV="Content-Type" VALUE="text/html; charset=utf-8">
}}}

Not all `HTTP-EQUIV` directives are meaningful - for example, the determination of `Content-Type`, `Content-Length`, `Location`, or `Content-Disposition` had already been made by the time HTML parsing begins - but some values seen may be set this way. The strategy for resolving HTTP - HTML conflicts is not outlined in W3C standards - but in practice, valid HTTP headers take precedence over `HTTP-EQUIV`; on the other hand, `HTTP-EQUIV` takes precedence over unrecognized HTTP header values. `HTTP-EQUIV` tags will also take precedence when the content is moved to non-HTTP media, such as saved to local disk.

Key security-relevant differences between HTML parsing modes in the aforementioned engines are shown below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| Nested HTML tags will be parsed (`<FOO <BAR...`)? || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
|| Nested parsing features recursive recovery (both `FOO` and `BAR` interpreted)? || (NO) || (NO) || || YES || YES || YES || NO || YES || YES ||
|| Parser resets out on invalid tag names (`<FOO="<BAR...`)? || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
|| Trace-back recovery on missing tag closure (`<FOO BAR="<BAZ(EOF)`)? || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || NO ||
|| SGML-style comment parsing permitted in strict mode (`--` and `>` may be split)? || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || NO ||
|| !-type tags are parsed in a non-HTML manner (`<!FOO BAR="-->"...` breaks)? || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || NO ||
|| Characters accepted as tag name / parameter separators (excluding `\t \r \n \x20`) || \x0B \x0C <font color="#ff0000">/</font> || \x0B \x0C <font color="#ff0000">/</font> || || <font color="#ff0000">/</font> || <font color="#ff0000">/</font> || \x0B \x0C || \x0B \x0C \xA0 || \x0B \x0C || \x0B \x0C ||
|| Characters ignored between parameter name, equals sign, and value (excluding `\t \r \n`) || \x0B \x0C \x20 || \x0B \x0C \x20 || || \x20 || \x20 || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> || \x20 \xA0 || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> ||
|| Characters accepted in lieu of quotes for HTML parameters (excluding `"`) || ' <font color="#ff0000">`</font> || ' <font color="#ff0000">`</font> || || ' || ' || ' || ' || ' || ' || 
|| Characters accepted in tag names (excluding `A-Z / ? !`) || <font color="#ff0000">\0 %*</font>|| <font color="#ff0000">\0 %</font> || || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#ff0000">\0</font> || <font color="#909090">none</font> || <font color="#909090">none</font> ||