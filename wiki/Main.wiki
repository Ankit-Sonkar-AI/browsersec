#summary Main wiki page
#labels Featured

=Browser Security Handbook=

  * Written and maintained by [http://lcamtuf.coredump.cx/ Michal Zalewski] <[mailto:lcamtuf@google.com lcamtuf@google.com]>. 
  * Copyright 2008 Google Inc, rights reserved.
  * Released under terms and conditions of the [http://creativecommons.org/licenses/by/3.0 CC-3.0-BY] license.

=Table of Contents=
<wiki:toc max_depth="10" />

=Introduction=

Hello, and welcome to _Browser Security Handbook_!

Browser Security Handbook is meant to provide web application developers, browser engineers, and information security researchers with a one-stop reference to key security properties of contemporary web browsers. Insufficient understanding of these often poorly-documented characteristics is a major contributing factor to the prevalence of several classes of security vulnerabilities.

Although all browsers implement roughly the same set of baseline features, there is relatively little conformance to standards when it comes to many of the less apparent characteristics. Furthermore, vendors routinely introduce poorly documented, proprietary tweaks or improvements that may interfere with existing features in non-obvious ways. For these reasons, it seemed prudent to compile this reference.

The current version of this document is based on the following versions of web browsers:

|| *Browser* || *Version* || *Test date* || *Notes* ||
|| Microsoft Internet Explorer 6 || 6.0.2900.5512 || Nov 18, 2008 || ||
|| Microsoft Internet Explorer 7 || 7.0.5730.11 || Nov 18, 2008 || ||
|| Microsoft Internet Explorer 8 (beta) || || || Not tested (pending stabilization). ||
|| Mozilla Firefox 2 || 2.0.0.17 || Nov 6, 2008 || ||
|| Mozilla Firefox 3 || 3.0.3 || Nov 18, 2008 || ||
|| Apple Safari || 3.2 || Nov 18, 2008 || ||
|| Opera || 9.62 || Nov 18, 2008 || ||
|| Google Chrome || 0.3.154.9 || Nov 18, 2008 || ||
|| Android  built-in browser || SDK 1.0 RC1 || Nov 10, 2008 || Tests requiring `file:///` targets not executed. ||

*DISCLAIMER: Although we tried to make this document as accurate as possible, some errors might have slipped through. Please use this document only as an initial reference, and independently verify any characteristics you wish to depend upon. All the test cases featured in this document are [http://browsersec.googlecode.com/files/browser_tests-1.0.tar.gz freely available for download].*

=Underlying technologies=

This section provides a review of core standards and technologies behind modern browsers, and their security-relevant properties. No specific attention is given to features implemented explicitly for security purposes; these are discussed in later in the document.

==Uniform Resource Locators==

All web resources are addressed with the use of uniform resource identifiers. Being able to properly parse the format, and make certain assumptions about the data present therein, is of significance to many server-side security mechanisms.

The abstract syntax for URIs is described in [http://www.ietf.org/rfc/rfc3986.txt RFC 3986]. The document defines a basic hierarchical URI structure, defining a white list of unreserved characters that may appear in URIs as-is as element names, with no particular significance assigned (`0-9 A-Z a-z - . _ ~`), spelling out reserved characters that have special meanings and can be used as-is only in their desired function (`: / ? # [ ] @ ! $ & ' ( ) * + , ; =`), and establishing a hexadecimal percent-denoted encoding (`%nn`) for everything outside these sets (including the stray `%` character itself).

Some additional mechanisms are laid out in [http://www.ietf.org/rfc/rfc1738.txt RFC 1738], which defines URI syntax within the scope of HTTP, FTP, NNTP, Gopher, and several other specific protocols. Together, these RFCs define the following syntax for common Internet resources (the compliance with a generic naming strategy is denoted by the `//` prefix):

{{{
scheme://[authority[:password]@](host_name|\[host_address\])[:port][/hierarchical/path/to/resource[?search_string][#fragment_id]]
}}}

Since the presence of a scheme is the key differentiator between relative references permitted in documents for usability reasons, and fully-qualified URLs, and since `:` itself has other uses later in the URL, the set of characters permitted for scheme name must be narrow and clearly defined (`0-9 A-Z a-z + - .`) so that all implementations may make the distinction accurately.

On top of the aforementioned documents, a W3C draft [http://www.w3.org/Addressing/rfc1630.txt RFC 1630] outlines some additional concepts, such as the exact HTTP search string syntax (`param1=val1[&param2=val2&...]`), or the ability to use the `+` sign as a shorthand notation for spaces (the character itself does not function in this capacity elsewhere in the URL, which is somewhat counterintuitive).

In practice, browsers deviate from these standards in many ways, for example accepting URLs with technically forbidden, and then trying to escape them automatically; or applying heuristics to handle incomplete or seemingly broken URLs. Here are some of the key differences that often need to be accounted for:

|| *Test* || *MSIE6* || *MSIE7* || *MSIE8* || *FF2* || *FF3* || *Safari* || *Opera* || *Chrome* || *Android* ||
|| Non-standard characters permitted in URL scheme fields (excluding `0-9 A-Z a-z + - .`) || \t \r \n || \t \r \n || || \t \r \n || \t \r \n || _none_ || \r \n *+UTF8* || *\0* \t \r \n || _none_ ||
|| Non-standard characters kept as-is, with no escaping, in URL queries (excluding `0-9 A-Z a-z - . _ ~ : / ? # [ ] @ ! $ & ' ( ) * + , ; =`) || *" < > \* ^ ` { | } \x7F || *" < > \* ^ ` { | } \x7F || || *\* ^ { | } || *\* ^ { | } || ^ { | } || ^ { | } \x7F || *" \* ^ ` { | } || _tbd_ ||
|| Non-standard characters fully ignored in host names || \t \r \n || \t \r \n \xAD || || \t \r \n \xAD || \t \r \n \xAD || \xAD || \x0A-\x0D \xA0 \xAD || \t \r \n \xAD || _none_ ||
|| Types of partial or broken URLs auto-corrected to fully qualified ones || //y \\y || //y \\y || || //y x:///y x://`[y]` || //y x:///y x://`[y]` || //y \\y x:/y x:///y || //y \\y x://`[y]` || //y \\y x:///y || //y \\y ||
|| Fragment ID (hash) encoded by applying RFC-mandated URL escaping rules? || *NO* || *NO* || || *PARTLY* || *PARTLY* || YES || *NO* || *NO* || YES ||

_NOTE: As an anti-phishing mechanism, additional restrictions on the use of `authority` and `password` fields in URLs are imposed by many browsers; see the section on HTTP authentication later on._

Please note that when links are embedded within HTML documents, [http://www.w3.org/TR/REC-html40/charset.html#h-5.3.2 HTML entity decoding] takes place before the link is parsed. Because of this, if a newline is ignored in URL schemes, a link such as `javascript&#09;:alert(1)` may be accepted and executed as Javascript, just as `javascript<TAB>:alert(1)` would be.

==Unicode in URLs==

Much like several related technologies used for web content transport, URLs do not have any particular character set defined by relevant RFCs; [http://www.ietf.org/rfc/rfc3986.txt RFC 3986] ambiguously states: _"In local or regional contexts and with improving technology, users might benefit from being able to use a wider range of characters; such use is not defined by this specification."_ The same dismissive approach is taken in HTTP header specification.

As a result, in the context of web URLs, any high-bit user input may and should be escaped as `%nn` sequences, but there is no specific guidance provided on how to transcode user input in system's native code page when talking to other parties that may not share this code page. On a system that uses UTF-8 and receives an URL containing Unicode `ą` in the path, this corresponds to a sequence of `0xC4 0x85` natively; however, when sent to a server that uses `ISO-8859-2`, the correct value sent should be `0xB1` (or alternatively, additional information about client-specific encoding should be included to make the conversion possible on server side). In practice, most browsers deal with this by sending UTF-8 data by default on any text entered in the URL bar by hand, and using page encoding on all followed links.

Another limitation of URLs traces back to DNS as such; [http://www.ietf.org/rfc/rfc1035.txt RFC 1035] permits only characters `A-Z a-z 0-9 -` in DNS labels, with period (`.`) used as a delimiter; some resolver implementations further permit underscore (`_`) to appear in DNS names, violating the standard, but other characters are almost universally banned. With the growth of the Web, the need to accommodate non-Latin alphabets in host names was perceived by multiple parties - and the use of `%nn` encoding was not an option, because `%` as such was not on the list.

To solve this, [http://tools.ietf.org/html/rfc3490 RFC 3490] lays out a rather contrived encoding scheme that permitted Unicode data to be stored in DNS labels, and [http://tools.ietf.org/html/rfc3492 RFC 3492] outlines a specific implementation within DNS labels - commonly referred to as Punycode - that follows the notation of `xn--[US-ASCII part]-[encoded Unicode data]`. Any Punycode-aware browser faced with non US-ASCII data in a host name is expected to transform it to this notation first, and then perform a traditional DNS lookup for the encoded string.

Putting these two methods together, the following transformation is expected to be made internally by the browser:

{{{
http://www.ręczniki.pl/?ręcznik=1 → http://www.xn--rczniki-98a.pl/?r%C4%99cznik=1
}}}

Key security-relevant differences in high-bit URL handling are outlined below:

|| *Test* || *MSIE6* || *MSIE7* || *MSIE8* || *FF2* || *FF3* || *Safari* || *Opera* || *Chrome* || *Android* ||
|| Request URL path encoding when following plain links || UTF-8 || UTF-8 || || page encoding || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 ||
|| Request URL query string encoding when following plain links || *page encoding, no escaping* || *page encoding, no escaping* || || page encoding || page encoding || page encoding || page encoding || page encoding || page encoding ||
|| Request URL path encoding for `XMLHttpRequest` calls || page encoding || page encoding || || page encoding || page encoding || page encoding || page encoding || page encoding || page encoding ||
|| Request URL query string encoding for `XMLHttpRequest` calls || *page encoding, no escaping* || *page encoding, no escaping* || || page encoding || page encoding || *mangled* || page encoding || *mangled* || *mangled* || 
|| Request URL path encoding for manually entered URLs || UTF-8 || UTF-8 || || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 ||
|| Request URL query string encoding for manually entered URLs || *transcoded to 7-bit* || *transcoded to 7-bit* || || UTF-8 || UTF-8 || UTF-8 || *stripped to `?`* || UTF-8 || UTF-8 ||
|| Raw Unicode in host names auto-converted to Punycode? || NO || YES || || YES || YES || YES || YES || YES || NO ||
|| Percent-escaped UTF-8 in host names auto-converted to Punycode? || (NO) || YES || || *NO* || *on retry* || YES || YES || YES || (NO) ||
|| URL bar Unicode display method for host names || (Punycode) || Unicode || || Unicode || Unicode || Unicode || Unicode || Punycode || (Punycode) ||
|| URL bar Unicode display method outside host names || Unicode || Unicode || || `%nn` || Unicode || Unicode || as `?` || Unicode || _n/a_ ||

 
_NOTE: As an anti-phishing mechanism, additional restrictions on the use of some or all Unicode characters in certain top-level domains are imposed by many browsers; see domain name restrictions chapter later on._

==True URL schemes==

URL schemes are used to indicate what general protocol needs to be used to retrieve the data, and how the information needs to be processed for display. Schemes may also be tied to specific default values of some URL fields - such as a TCP port - or specific non-standard URL syntax parsing rules (the latter is usually denoted by the absence of a `//` string after scheme identifier).

Back in 1994, [http://www.ietf.org/rfc/rfc1738.txt RFC 1738] laid out several URL schemes in the context of web browsing, some of which are not handled natively by browsers, or have fallen into disuse. As the Web matured, multiple new open and proprietary schemes appeared with little or no consistency, and the set of protocols supported by each browser began to diverge. [http://www.ietf.org/rfc/rfc2718.txt RFC 2718] attempted to specify some ground rules for the creation of new protocols, and [http://www.ietf.org/rfc/rfc4395.txt RFC 4395] mandated that new schemes be registered with IANA (their list is [http://www.iana.org/assignments/uri-schemes.html available here]). In practice, however, few parties could be bothered to follow this route.

To broadly survey the capabilities of modern browsers, it makes sense to divide URL schemes into a group natively supported by the software, and another group supported by a plethora of plugins, extensions, or third-party programs. The first list is relatively short:

|| *Scheme name* || *MSIE6* || *MSIE7* || *MSIE8* || *FF2* || *FF3* || *Safari* || *Opera* || *Chrome* || *Android* ||
|| HTTP ([http://www.ietf.org/rfc/rfc2616.txt RFC 2616]) || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| HTTPS ([http://www.ietf.org/rfc/rfc2616.txt RFC 2818]) || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| SHTTP ([http://www.ietf.org/rfc/rfc2660.txt RFC 2660]) || as HTTP || as HTTP || || NO || NO || NO || NO || NO || NO ||
|| FTP ([http://www.ietf.org/rfc/rfc1738.txt RFC 1738]) || YES || YES || || YES || YES || YES || YES || YES || NO ||
|| file ([http://www.ietf.org/rfc/rfc1738.txt RFC 1738]) || YES || YES || || YES (local) || YES (local) || YES (local) || YES || YES || _tbd_ ||
|| Gopher ([http://www.ietf.org/rfc/rfc14266.txt RFC 4266]) || NO || NO || || YES || YES || NO || defunct? || NO || NO ||
|| news ([http://tools.ietf.org/html/draft-ellermann-news-nntp-uri-11 draft RFC]) || NO || NO || || NO || NO || NO || YES || NO || NO ||

These protocols may be used to deliver natively rendered content that is interpreted and executed using the security rules implemented within the browsers.

The other list, third-party protocols routed to other applications, depends quite heavily on system configuration. The set of protocols and their handlers is usually maintained in a separate system-wide registry. Browsers may whitelist some of them by default (executing external programs without prompting), or blacklist some (preventing their use altogether); the default action is often to display a mildly confusing prompt. Most common protocols in this family include:

{{{
acrobat                           - Acrobat Reader
callto                            - some instant messengers, IP phones
daap / itpc / itms / ...          - Apple iTunes
FirefoxURL                        - Mozilla Firefox
hcp                               - Microsoft Windows Help subsystem
ldap                              - address book functionality
mailto                            - various mail agents
mmst / mmsu / msbd / rtsp / ...   - streaming media of all sorts
mso-offdap                        - Microsoft Office
news / snews / nntp               - various news clients
outlook / stssync                 - Microsoft Outlook
rlogin / telnet / tn3270          - telnet client
shell                             - Windows Explorer
sip                               - various IP phone software
}}}

New handlers might be registered in OS- and application-specific ways, for example by registering new `HKCR\Protocols\Handlers` keys in Windows registry, or adding `network.protocol-handler.*` settings in Firefox.

As a rule, the latter set of protocols is not honored within the renderer when referencing document elements such as images, script or applet sources, and so forth; they do work, however, as `IFRAME` and link targets, and will launch a separate program as needed. These programs may sometimes integrate seamlessly with the renderer, but the rules by which they render content and impose security restrictions are generally unrelated to the browser as such.

Historically, the ability to plant such third-party schemes in links proved to be a significant exploitation vector, as poorly written, vulnerable external programs often register protocol handlers without user's knowledge or consent; as such, it is prudent to reject unexpected schemes where possible, and exercise caution when introducing new ones on client side (including observing [http://www.securityfocus.com/bid/24837/ safe parameter passing conventions]).