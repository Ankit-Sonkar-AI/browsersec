#summary Main wiki page
#labels Featured

<h1>Browser Security Handbook</h1>

  * Written and maintained by [http://lcamtuf.coredump.cx/ Michal Zalewski] <[mailto:lcamtuf@google.com lcamtuf@google.com]>. 
  * Copyright 2008 Google Inc, rights reserved.
  * Released under terms and conditions of the [http://creativecommons.org/licenses/by/3.0 CC-3.0-BY] license.

<h1>Table of Contents</h1>

<wiki:toc max_depth="10" />

=Introduction=

Hello, and welcome to _Browser Security Handbook_!

Browser Security Handbook is meant to provide web application developers, browser engineers, and information security researchers with a one-stop reference to key security properties of contemporary web browsers. Insufficient understanding of these often poorly-documented characteristics is a major contributing factor to the prevalence of several classes of security vulnerabilities.

Although all browsers implement roughly the same set of baseline features, there is relatively little conformance to standards when it comes to many of the less apparent characteristics. Furthermore, vendors routinely introduce poorly documented, proprietary tweaks or improvements that may interfere with existing features in non-obvious ways. For these reasons, it seemed prudent to compile this reference.

The current version of this document is based on the following versions of web browsers:

|| <font color="#3050a0">*Browser*</font> || <font color="#3050a0">*Version*</font> || <font color="#3050a0">*Test date*</font> || <font color="#3050a0">*Notes*</font> ||
|| Microsoft Internet Explorer 6 || 6.0.2900.5512 || Nov 18, 2008 || ||
|| Microsoft Internet Explorer 7 || 7.0.5730.11 || Nov 18, 2008 || ||
|| <font color="#909090">Microsoft Internet Explorer 8 (beta)</font> || || || <font color="#909090">Not tested - pending stabilization.</font> ||
|| Mozilla Firefox 2 || 2.0.0.17 || Nov 6, 2008 || ||
|| Mozilla Firefox 3 || 3.0.3 || Nov 18, 2008 || ||
|| Apple Safari || 3.2 || Nov 18, 2008 || ||
|| Opera || 9.62 || Nov 18, 2008 || ||
|| Google Chrome || 0.3.154.9 || Nov 18, 2008 || ||
|| Android  embedded browser || SDK 1.0 RC1 || Nov 10, 2008 || Tests requiring `file:///` targets not executed. ||

<b></b>

=Disclaimers and typographical conventions=

*Please note that although we tried to make this document as accurate as possible, some errors might have slipped through. Use this document only as an initial reference, and independently verify any characteristics you wish to depend upon. All the test cases featured in this document are [http://browsersec.googlecode.com/files/browser_tests-1.0.tar.gz freely available for download].*

Through the document, <font color="#ff0000">red color</font> is used to bring attention to browser properties seeem particularly tricky or unexpected, and need to be carefully accounted for in server-side implementations. Whenever status quo appears to bear no significant security consequences and is well-understood, but a particular browser implementation takes additional steps to protect application developers, we use <font color="#30ff30">green color</font> to denote this, likewise. Rest assured, neither of these color codes implies that a particular browser is less or more secure than its counterparts.

=Basic concepts behind web browsers=

This section provides a review of core standards and technologies behind modern browsers, and their security-relevant properties. No specific attention is given to features implemented explicitly for security purposes; these are discussed in later in the document.

==Uniform Resource Locators==

All web resources are addressed with the use of uniform resource identifiers. Being able to properly parse the format, and make certain assumptions about the data present therein, is of significance to many server-side security mechanisms.

The abstract syntax for URIs is described in [http://www.ietf.org/rfc/rfc3986.txt RFC 3986]. The document defines a basic hierarchical URI structure, defining a white list of unreserved characters that may appear in URIs as-is as element names, with no particular significance assigned (`0-9 A-Z a-z - . _ ~`), spelling out reserved characters that have special meanings and can be used as-is only in their desired function (`: / ? # [ ] @ ! $ & ' ( ) * + , ; =`), and establishing a hexadecimal percent-denoted encoding (`%nn`) for everything outside these sets (including the stray `%` character itself).

Some additional mechanisms are laid out in [http://www.ietf.org/rfc/rfc1738.txt RFC 1738], which defines URI syntax within the scope of HTTP, FTP, NNTP, Gopher, and several other specific protocols. Together, these RFCs define the following syntax for common Internet resources (the compliance with a generic naming strategy is denoted by the `//` prefix):

{{{
scheme://[authority[:password]@](host_name|\[host_address\])[:port][/hierarchical/path/to/resource[?search_string][#fragment_id]]
}}}

Since the presence of a scheme is the key differentiator between relative references permitted in documents for usability reasons, and fully-qualified URLs, and since `:` itself has other uses later in the URL, the set of characters permitted for scheme name must be narrow and clearly defined (`0-9 A-Z a-z + - .`) so that all implementations may make the distinction accurately.

On top of the aforementioned documents, a W3C draft [http://www.w3.org/Addressing/rfc1630.txt RFC 1630] outlines some additional concepts, such as the exact HTTP search string syntax (`param1=val1[&param2=val2&...]`), or the ability to use the `+` sign as a shorthand notation for spaces (the character itself does not function in this capacity elsewhere in the URL, which is somewhat counterintuitive).

In practice, browsers deviate from these standards in many ways, for example accepting URLs with technically forbidden, and then trying to escape them automatically; or applying heuristics to handle incomplete or seemingly broken URLs. Here are some of the key differences that often need to be accounted for:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Non-standard characters permitted in URL scheme fields (excluding `0-9 A-Z a-z + - .`)</font> || \t \r \n || \t \r \n || || \t \r \n || \t \r \n || <font color="#909090">none</font> || \r \n <font color="#ff0000">+UTF8</font> || <font color="#ff0000">\0</font> \t \r \n || <font color="#909090">none</font> ||
|| <font color="#3050a0">Non-standard characters kept as-is, with no escaping, in URL queries (excluding `0-9 A-Z a-z - . _ ~ : / ? # [ ] @ ! $ & ' ( ) * + , ; =`)</font> || <font color="#ff0000">" < > \</font> ^ ` { | } \x7F || <font color="#ff0000">" < > \</font> ^ ` { | } \x7F || || <font color="#ff0000">\</font> ^ { | } || <font color="#ff0000">\</font> ^ { | } || ^ { | } || ^ { | } \x7F || <font color="#ff0000">" \</font> ^ ` { | } || <font color="#909090">tbd</font> ||
|| <font color="#3050a0">Non-standard characters fully ignored in host names</font> || \t \r \n || \t \r \n \xAD || || \t \r \n \xAD || \t \r \n \xAD || \xAD || \x0A-\x0D \xA0 \xAD || \t \r \n \xAD || <font color="#909090">none</font> ||
|| <font color="#3050a0">Types of partial or broken URLs auto-corrected to fully qualified ones</font> || //y \\y || //y \\y || || //y x:///y x://`[y]` || //y x:///y x://`[y]` || //y \\y x:/y x:///y || //y \\y x://`[y]` || //y \\y x:///y || //y \\y ||
|| <font color="#3050a0">Fragment ID (hash) encoded by applying RFC-mandated URL escaping rules?</font> || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || || <font color="#ff0000">PARTLY</font> || <font color="#ff0000">PARTLY</font> || YES || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || YES ||

_NOTE: As an anti-phishing mechanism, additional restrictions on the use of `authority` and `password` fields in URLs are imposed by many browsers; see the section on HTTP authentication later on._

Please note that when links are embedded within HTML documents, [http://www.w3.org/TR/REC-html40/charset.html#h-5.3.2 HTML entity decoding] takes place before the link is parsed. Because of this, if a newline is ignored in URL schemes, a link such as `javascript&#09;:alert(1)` may be accepted and executed as Javascript, just as `javascript<TAB>:alert(1)` would be.

===Unicode in URLs===

Much like several related technologies used for web content transport, URLs do not have any particular character set defined by relevant RFCs; [http://www.ietf.org/rfc/rfc3986.txt RFC 3986] ambiguously states: _"In local or regional contexts and with improving technology, users might benefit from being able to use a wider range of characters; such use is not defined by this specification."_ The same dismissive approach is taken in HTTP header specification.

As a result, in the context of web URLs, any high-bit user input may and should be escaped as `%nn` sequences, but there is no specific guidance provided on how to transcode user input in system's native code page when talking to other parties that may not share this code page. On a system that uses UTF-8 and receives a URL containing Unicode `Ä…` in the path, this corresponds to a sequence of `0xC4 0x85` natively; however, when sent to a server that uses `ISO-8859-2`, the correct value sent should be `0xB1` (or alternatively, additional information about client-specific encoding should be included to make the conversion possible on server side). In practice, most browsers deal with this by sending UTF-8 data by default on any text entered in the URL bar by hand, and using page encoding on all followed links.

Another limitation of URLs traces back to DNS as such; [http://www.ietf.org/rfc/rfc1035.txt RFC 1035] permits only characters `A-Z a-z 0-9 -` in DNS labels, with period (`.`) used as a delimiter; some resolver implementations further permit underscore (`_`) to appear in DNS names, violating the standard, but other characters are almost universally banned. With the growth of the Web, the need to accommodate non-Latin alphabets in host names was perceived by multiple parties - and the use of `%nn` encoding was not an option, because `%` as such was not on the list.

To solve this, [http://tools.ietf.org/html/rfc3490 RFC 3490] lays out a rather contrived encoding scheme that permitted Unicode data to be stored in DNS labels, and [http://tools.ietf.org/html/rfc3492 RFC 3492] outlines a specific implementation within DNS labels - commonly referred to as Punycode - that follows the notation of `xn--[US-ASCII part]-[encoded Unicode data]`. Any Punycode-aware browser faced with non US-ASCII data in a host name is expected to transform it to this notation first, and then perform a traditional DNS lookup for the encoded string.

Putting these two methods together, the following transformation is expected to be made internally by the browser:

{{{
http://www.rÄ™czniki.pl/?rÄ™cznik=1 â†’ http://www.xn--rczniki-98a.pl/?r%C4%99cznik=1
}}}

Key security-relevant differences in high-bit URL handling are outlined below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Request URL path encoding when following plain links</font> || UTF-8 || UTF-8 || || page encoding || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 ||
|| <font color="#3050a0">Request URL query string encoding when following plain links</font> || <font color="#ff0000">page encoding, no escaping</font> || <font color="#ff0000">page encoding, no escaping</font> || || page encoding || page encoding || page encoding || page encoding || page encoding || page encoding ||
|| <font color="#3050a0">Request URL path encoding for `XMLHttpRequest` calls</font> || page encoding || page encoding || || page encoding || page encoding || page encoding || page encoding || page encoding || page encoding ||
|| <font color="#3050a0">Request URL query string encoding for `XMLHttpRequest` calls</font> || <font color="#ff0000">page encoding, no escaping</font> || <font color="#ff0000">page encoding, no escaping</font> || || page encoding || page encoding || <font color="#ff0000">mangled</font> || page encoding || <font color="#ff0000">mangled</font> || <font color="#ff0000">mangled</font> || 
|| <font color="#3050a0">Request URL path encoding for manually entered URLs</font> || UTF-8 || UTF-8 || || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 || UTF-8 ||
|| <font color="#3050a0">Request URL query string encoding for manually entered URLs</font> || <font color="#ff0000">transcoded to 7 bit</font> || <font color="#ff0000">transcoded to 7-bit</font> || || UTF-8 || UTF-8 || UTF-8 || <font color="#ff0000">stripped to `?`</font> || UTF-8 || UTF-8 ||
|| <font color="#3050a0">Raw Unicode in host names auto-converted to Punycode?</font> || NO || YES || || YES || YES || YES || YES || YES || NO ||
|| <font color="#3050a0">Percent-escaped UTF-8 in host names auto-converted to Punycode?</font> || (NO) || YES || || <font color="#ff0000">NO</font> || <font color="#ff0000">on retry</font> || YES || YES || YES || (NO) ||
|| <font color="#3050a0">URL bar Unicode display method for host names</font> || (Punycode) || Unicode || || Unicode || Unicode || Unicode || Unicode || Punycode || (Punycode) ||
|| <font color="#3050a0">URL bar Unicode display method outside host names</font> || Unicode || Unicode || || `%nn` || Unicode || Unicode || as `?` || Unicode || <font color="#909090">n/a</font> ||

 
_NOTE: As an anti-phishing mechanism, additional restrictions on the use of some or all Unicode characters in certain top-level domains are imposed by many browsers; see domain name restrictions chapter later on._

==True URL schemes==

URL schemes are used to indicate what general protocol needs to be used to retrieve the data, and how the information needs to be processed for display. Schemes may also be tied to specific default values of some URL fields - such as a TCP port - or specific non-standard URL syntax parsing rules (the latter is usually denoted by the absence of a `//` string after scheme identifier).

Back in 1994, [http://www.ietf.org/rfc/rfc1738.txt RFC 1738] laid out several URL schemes in the context of web browsing, some of which are not handled natively by browsers, or have fallen into disuse. As the Web matured, multiple new open and proprietary schemes appeared with little or no consistency, and the set of protocols supported by each browser began to diverge. [http://www.ietf.org/rfc/rfc2718.txt RFC 2718] attempted to specify some ground rules for the creation of new protocols, and [http://www.ietf.org/rfc/rfc4395.txt RFC 4395] mandated that new schemes be registered with IANA (their list is [http://www.iana.org/assignments/uri-schemes.html available here]). In practice, however, few parties could be bothered to follow this route.

To broadly survey the capabilities of modern browsers, it makes sense to divide URL schemes into a group natively supported by the software, and another group supported by a plethora of plugins, extensions, or third-party programs. The first list is relatively short:

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">HTTP ([http://www.ietf.org/rfc/rfc2616.txt RFC 2616])</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">HTTPS ([http://www.ietf.org/rfc/rfc2616.txt RFC 2818])</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">SHTTP ([http://www.ietf.org/rfc/rfc2660.txt RFC 2660])</font> || as HTTP || as HTTP || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">FTP ([http://www.ietf.org/rfc/rfc1738.txt RFC 1738])</font> || YES || YES || || YES || YES || YES || YES || YES || NO ||
|| <font color="#3050a0">file ([http://www.ietf.org/rfc/rfc1738.txt RFC 1738])</font> || YES || YES || || YES (local) || YES (local) || YES (local) || YES || YES || _tbd_ ||
|| <font color="#3050a0">Gopher ([http://www.ietf.org/rfc/rfc14266.txt RFC 4266])</font> || NO || NO || || YES || YES || NO || defunct? || NO || NO ||
|| <font color="#3050a0">news ([http://tools.ietf.org/html/draft-ellermann-news-nntp-uri-11 draft RFC])</font> || NO || NO || || NO || NO || NO || YES || NO || NO ||

These protocols may be used to deliver natively rendered content that is interpreted and executed using the security rules implemented within the browsers.

The other list, third-party protocols routed to other applications, depends quite heavily on system configuration. The set of protocols and their handlers is usually maintained in a separate system-wide registry. Browsers may whitelist some of them by default (executing external programs without prompting), or blacklist some (preventing their use altogether); the default action is often to display a mildly confusing prompt. Most common protocols in this family include:

{{{
acrobat                           - Acrobat Reader
callto                            - some instant messengers, IP phones
daap / itpc / itms / ...          - Apple iTunes
FirefoxURL                        - Mozilla Firefox
hcp                               - Microsoft Windows Help subsystem
ldap                              - address book functionality
mailto                            - various mail agents
mmst / mmsu / msbd / rtsp / ...   - streaming media of all sorts
mso-offdap                        - Microsoft Office
news / snews / nntp               - various news clients
outlook / stssync                 - Microsoft Outlook
rlogin / telnet / tn3270          - telnet client
shell                             - Windows Explorer
sip                               - various IP phone software
}}}

New handlers might be registered in OS- and application-specific ways, for example by registering new `HKCR\Protocols\Handlers` keys in Windows registry, or adding `network.protocol-handler.*` settings in Firefox.

As a rule, the latter set of protocols is not honored within the renderer when referencing document elements such as images, script or applet sources, and so forth; they do work, however, as `IFRAME` and link targets, and will launch a separate program as needed. These programs may sometimes integrate seamlessly with the renderer, but the rules by which they render content and impose security restrictions are generally unrelated to the browser as such.

Historically, the ability to plant such third-party schemes in links proved to be a significant exploitation vector, as poorly written, vulnerable external programs often register protocol handlers without user's knowledge or consent; as such, it is prudent to reject unexpected schemes where possible, and exercise caution when introducing new ones on client side (including observing [http://www.securityfocus.com/bid/24837/ safe parameter passing conventions]).

==Pseudo URL schemes==

In addition to the aforementioned "true" URL schemes, modern browsers support a large number of pseudo-schemes used to implement various advanced features, such as encapsulating encoded documents within URLs, providing legacy scripting features, or giving access to internal browser information and data views.

Encapsulating schemes are of interest to any link-handling applications, as these methods usually impose specific non-standard content parsing or rendering modes on top of existing resources specified in the later part of the URL. The underlying content is retrieved using HTTP, looked up locally (e.g., `file:///`), or obtained using other generic method - and may execute in the security context associated with the true origin of data. For example, the following URL:

{{{
jar:http://www.example.com/archive.jar!/resource.html
}}}

...will be retrieved over HTTP from `http://www.example.com/archive.jar`. Because of the encapsulating protocol, the browser will then attempt to interpret the obtained file as a standard Sun Java ZIP archive (`JAR`), and extract, then display `/resource.html` from within that archive.

Common encapsulating schemes are shown in the table below.

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">feed (RSS, [http://www.brindys.com/winrss/feedformat.html draft spec])</font> || NO || NO || || NO || NO || YES || NO || NO || NO ||
|| <font color="#3050a0">hcp, its, mhtml, mk, ms-help, ms-its, ms-itss (Windows help archive parsing)</font> || YES || YES || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">jar ([http://docs.sun.com/source/819-0913/author/jar.html Java archive parsing])</font> || NO || NO || || YES || YES || NO || NO || NO || NO ||
|| <font color="#3050a0">view-cache, wyciwyg (cached page views)</font> || NO || NO || || YES || YES || NO || NO || YES || NO ||
|| <font color="#3050a0">view-source (page source views)</font> || NO || NO || || YES || YES || NO || NO || YES || NO ||

In addition to encapsulating schemes enumerated above, there are various schemes used for accessing browser-specific internal features unrelated to web content. These pseudo-protocols include `about:` (used to access static info pages, errors, cache statistics, configuration pages, [http://en.wikipedia.org/wiki/About: and more]), `moz-icon:` (used to access file icons), `chrome:`, `chrome-resource:`, `chromewebdata:`, `resource:`, `res:`, `rdf:`, and `inspector:` (all used to reference built-in resources of the browser, often rendered with elevated privileges). There is little or no standardization or proper documentation for these mechanisms, but as a general rule, web content is not permitted to directly reference any sensitive data. Permitting them to go through on trusted pages may serve as an attack vector in case of browser-side vulnerabilities, however.

Finally, several pseudo-schemes exist specifically to enable scripting or URL-contained data rendering in the security context inherited from the caller, without actually referencing any additional external or internal content. It is particularly unsafe to output attacker-controlled URLs of this type on pages that may contain any sensitive content. Known schemes of this type include:

|| <font color="#3050a0">*Scheme name*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">data (in-place documents, [http://www.ietf.org/rfc/rfc2397.txt RFC 2397])</font> || NO || NO || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">javascript ([http://developer.mozilla.org/en/docs/JavaScript web scripting])</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">vbscript ([http://msdn.microsoft.com/en-us/library/sx7b3k7y(VS.85).aspx Microsoft proprietary scripting])</font> || YES || YES || || NO || NO || NO || NO || NO || NO ||


_NOTE: Historically, numerous aliases for these schemes were also present; `livescript` and `mocha` schemes were supported by Netscape Navigator and other early browsers as aliases for Javascript; `local` worked in some browsers as a nickname for `file`; etc. This is generally not seen anymore._

==Hypertext Transfer Protocol==

The core protocol used to request and annotate much of web traffic is called the Hypertext Transfer Protocol. This text-based scheme originated as a very simple, underspecified design drafted by Tim Berners-Lee, and dubbed HTTP/0.9 ([http://www.w3.org/Protocols/HTTP/AsImplemented.html see W3C archive]) - these days no longer used by web browsers, but recognized by some servers. It then evolved into a fairly complex, and still somewhat underspecified HTTP/1.1, as described in [http://www.ietf.org/rfc/rfc2616.txt RFC 2616], whilst maintaining some superficial backward compatibility with the original idea.

Every HTTP request opens with a single-line description of a content access method (`GET` meant for requesting basic content, and `POST` meant for submitting state-changing data to servers - along with plethora of more specialized options typically not used by web browsers under normal circumstances). In HTTP/1.0 and up, this is then followed by protocol version specification - and the opening line itself is followed by zero or more additional `field: value` headers, each occupying their own line. These headers specify all sorts of meta-data, from target host name (so that a single machine may host multiple web sites), to information about client-supported MIME types, cache parameters, the site from which a particular request originated (`Referer`), and so forth. Headers are terminated with a single empty line, followed by any optional payload data being sent to the server if specified by a `Content-Length` header. 

One example of an HTTP request might be:

{{{
POST /fuzzy_bunnies/images/bunny_dispenser.php HTTP/1.1
Host: www.fuzzybunnies.com
User-Agent: Bunny Browser 1.7
Content-Type: text/plain
Content-Length: 11
Referer: http://www.fuzzybunnies.com/main.html

HELLO SERVER
}}}

The server responds in a similar manner, returning a numerical status code, spoken protocol version, and similarly formatted metadata headers followed by actual content requested, if available:

{{{
HTTP/1.1 200 OK
Server: Bunny Server 0.9.2
Content-Type: text/plain

HELLO CLIENT
}}}

Originally, every connection would be one-shot: after a request is sent, and response received, the session is terminated, and a new connection needs to be established. Since the need to carry out a complete TCP/IP handshake for every request imposed a performance penalty, newer specifications introduced the concept of keep-alive connections, negotiated with a particular request header that is then acknowledged by the server.

This, in conjunction with the fact that HTTP supports proxying and content caching on interim systems managed by content providers, ISPs, and individual subscribers, made it particularly important for all parties involved in an HTTP transaction to have exactly the same idea of where a request starts, where it ends, and what it is related to. Unfortunately, the protocol itself is highly ambiguous and has a potential for redundancy, which leads to multiple problems and differences between how servers, clients, and proxies may interpret responses:

  * Like many other text protocols of that time, early takes on HTTP made little or no effort to mandate a strict adherence to a particular understanding of what a text-based format really is, or how certain "intuitive" field values must be structured. Because of this, implementations would recognize, and often handle in incompatible ways, technically malformed inputs - such as incorrect newline characters (lone `CR`, lone `LF`, `LF CR`), `NUL` or other disruptive control characters in text, incorrect number of whitespaces in field delimiters, and so forth; to various implementations, `Head\0er: Value` may appear as `Head`, `Head: Value`, `Header: Value`, or `Head\0er: Value`. In later versions, as outlined in RFC 2616 section 19.3 ("Tolerant Applications"), the standard explicitly recommends, but does not require, lax parsing of certain fields and invalid values. One of the most striking examples of compatibility kludges is Firefox [http://mxr.mozilla.org/mozilla1.8.0/source/nsprpub/pr/src/misc/prtime.c#1045 prtime.c] function used to parse HTTP `Date` fields, which shows a stunning complexity behind what should be a remarkably simple task.

  * No particular high bit character set is defined for HTTP headers, and high bit characters are technically disallowed, despite legitimate reasons for them to appear in certain HTTP fields (e.g., `Cookie`, `Content-Disposition` filenames), and the protocol having no provisions for any particular method of escaping them. This resulted in some implementations interpreting HTTP data as UTF-8, and some using single-byte interpretations native to low-level OS string handling facilities.

   * The behavior when some headers critical to the correct understanding of an HTTP request are duplicate or contradictory is not well defined; as such, various clients will give precedence to different occurrences of the same parameter within HTTP headers (e.g., duplicate `Content-Type`), or assign various weights to conflicting information (say, `Content-Length` not matching payload length).

   * When new features that change the meaning of requests were introduced in HTTP/1.1 standard, no strict prohibition against recognizing them in requests or responses marked as HTTP/1.0 was made. As a result, the understanding of HTTP/1.0 traffic may differ significantly between legacy agents, such as some commercial web proxies, and HTTP/1.1 applications such as contemporary browsers (e.g., `Connection: keep-alive`, `Transfer-Encoding: chunked`, `Accept-Encoding: ...`).

Many specific areas, such as caching behavior, have their own sections later in this document. Below is a survey of general security-relevant differences in HTTP protocol implementations:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">`Content-Length` header value overrides actual content length?</font> || NO || YES || || NO || NO || YES || YES || NO || YES ||
|| <font color="#3050a0">First HTTP header of the same name takes precedence?</font> || YES || YES || || NO || NO || YES || NO || NO || NO ||
|| <font color="#3050a0">First field value in a HTTP header takes precedence?</font> || YES || YES || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">`Referer` header disclosed on HTTPS â†’ HTTPS navigation?</font> || YES || YES || || YES || YES || YES || <font color="#30ff30">NO</font> || YES || YES ||
|| <font color="#3050a0">`Referer` header disclosed on HTTPS â†’ HTTP navigation?</font> || NO || NO || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Response body on invalid 30x redirect shown to user?</font> || NO || NO || || YES || YES || NO || YES || YES || NO ||

==Hypertext Markup Language==

Hypertext Markup Language, the primary document format rendered by modern web browsers, has its roots with [http://en.wikipedia.org/wiki/SGML Standard Generalized Markup Language], a standard for machine-readable documents. The initial [http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html HTML draft] provided a very limited syntax intended strictly to define various functional parts of the document. With the rapid development of web browsers, this basic technology got extended very rapidly and with little oversight to provide additional features related to visual presentation, scripting, and various perplexing and proprietary bells and whistles. Perhaps more interestingly, the format was also extended to provide the ability to embed other, non-HTTP multimedia content on pages, nest HTML documents within frames, and submit complex data structures and client-supplied files.

The mess eventually led to a post-factum compromise standard dubbed [http://www.w3.org/TR/REC-html32 HTML 3.2]. The outcome of this explosive growth was a format needlessly hard to parse, and combining unique quirks, weird limitations, and deeply intertwined visual style and document structure information - and so ever since, W3C and WHATWG focused on making HTML a clean, strict, and well-defined language, a goal at least approximated with [http://www.w3.org/TR/html401/ HTML 4] and [http://www.w3.org/TR/xhtml2/ XHTML] (a variant of HTML that strictly conforms to XML syntax rules), as well as the ongoing work on [http://www.w3.org/TR/html5/ HTML 5].

This day, the four prevailing HTML document rendering implementations are:

  * [http://msdn.microsoft.com/en-us/library/aa741317.aspx Trident] (MSHTML) - used in MSIE6, MSIE7, MSIE8,
  * [http://developer.mozilla.org/en/Gecko Gecko] - used in Firefox and derivates,
  * [http://webkit.org/ WebKit] - used by Safari, Chrome, Android,
  * Presto - used in Opera.

The ability for various applications to accurately understand HTML document structure, as it would be seen by a browser, is an important security challenge. The serial nature of the HTML blends together code (Javascript, Flash, Java applets) and the actual data to be displayed - making it easy for attackers to smuggle dangerous directives along with useful layout information in any external content. Knowing exactly what is being rendered is often crucial to site security (see [http://code.google.com/p/doctype/wiki/ArticleXSS this article] for a broader discussion of the threat).

Sadly, for compatibility reasons, parsers operating in non-XML mode tend are generally remarkably lax and feature proprietary, incompatible, poorly documented recovery modes that make it very difficult for any platform to anticipate how a third-party HTML document would be interpreted. Any of the following grossly malformed examples may be interpreted as a scripting directive by some, but usually not all, renderers:

{{{
1: <B <SCRIPT>alert(1)</SCRIPT>>
2: <B="<SCRIPT>alert(1)</SCRIPT>">
3: <IMG SRC=`javascript:alert(1)`>
4: <S[0x00]CRIPT>alert(1)</S[0x00]CRIPT>
5: <A """><IMG SRC="javascript:alert(1)">
6: <IMG onmouseover =alert(1)>
7: <A/HREF="javascript:alert(1)">
8: <!-- Hello -- world > <SCRIPT>alert(1)</SCRIPT> -->
}}}

Cross-site scripting aside, another interesting property of HTML is that it permits certain HTTP directives to be encoded within HTML itself, using the following format:

{{{
<META HTTP-EQUIV="Content-Type" VALUE="text/html; charset=utf-8">
}}}

Not all `HTTP-EQUIV` directives are meaningful - for example, the determination of `Content-Type`, `Content-Length`, `Location`, or `Content-Disposition` had already been made by the time HTML parsing begins - but some values seen may be set this way. The strategy for resolving HTTP - HTML conflicts is not outlined in W3C standards - but in practice, valid HTTP headers take precedence over `HTTP-EQUIV`; on the other hand, `HTTP-EQUIV` takes precedence over unrecognized HTTP header values. `HTTP-EQUIV` tags will also take precedence when the content is moved to non-HTTP media, such as saved to local disk.

Key security-relevant differences between HTML parsing modes in the aforementioned engines are shown below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Parser resets on nested HTML tags (`<FOO <BAR...`)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Recursive recovery with nested tags (both `FOO` and `BAR` interpreted)?</font> || (NO) || (NO) || || YES || YES || YES || NO || YES || YES ||
|| <font color="#3050a0">Parser resets out on invalid tag names (`<FOO="<BAR...`)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
|| <font color="#3050a0">Trace-back recovery on missing tag closure (`<FOO BAR="<BAZ(EOF)`)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || NO ||
|| <font color="#3050a0">SGML-style comment parsing permitted in strict mode (`--` and `>` may appear separately)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || NO ||
|| <font color="#3050a0">!-type tags are parsed in a non-HTML manner (`<!FOO BAR="-->"...` breaks)?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || NO || NO ||
|| <font color="#3050a0">Characters accepted as tag name / parameter separators (excluding `\t \r \n \x20`)</font> || \x0B \x0C <font color="#ff0000">/</font> || \x0B \x0C <font color="#ff0000">/</font> || || <font color="#ff0000">/</font> || <font color="#ff0000">/</font> || \x0B \x0C || \x0B \x0C \xA0 || \x0B \x0C || \x0B \x0C ||
|| <font color="#3050a0">Characters ignored between parameter name, equals sign, and value (excluding `\t \r \n`)</font> || \x0B \x0C \x20 || \x0B \x0C \x20 || || \x20 || \x20 || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> || \x20 \xA0 || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> || \0 \x0B \x0C \x20 <font color="#ff0000">/</font> ||
|| <font color="#3050a0">Characters accepted in lieu of quotes for HTML parameters (excluding `"`)</font> || ' <font color="#ff0000">`</font> || ' <font color="#ff0000">`</font> || || ' || ' || ' || ' || ' || ' || 
|| <font color="#3050a0">Characters accepted in tag names (excluding `A-Z / ? !`)</font> || <font color="#ff0000">\0 %*</font>|| <font color="#ff0000">\0 %</font> || || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#ff0000">\0</font> || <font color="#909090">none</font> || <font color="#909090">none</font> ||

===HTML entity encoding===

HTML features a special encoding scheme called [http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references HTML entities]. The purpose of this scheme is to make it possible to safely render certain reserved HTML characters (e.g., `< > &`) within documents, as well as to carry high bit characters safely over 7-bit media. The scheme nominally permits three types of notation:

  * One of predefined, named entities, in the format of `&<name>;` - for example `&lt;` for `<`, `&gt;` for `>`, `&rarr;` for `â†’`, etc,

  * Decimal entities, `&#<nn>;`, with a number corresponding to the desired Unicode character value - for example `&#60;` for `<`, `&#8594;` for `â†’`,

  * Hexadecimal entities, `&#x<nn>;`, likewise - for example `&#x3c;` for `<`, `&#x2192;` for `â†’`.

In every browser, HTML entities are decoded only in parameter values and stray text between tags. Entities have no effect on how the general structure of a document is understood, and no special meaning in sections such as `<SCRIPT>`. The ability to understand and parse the syntax is still critical to properly understanding the value of a particular HTML parameter, however. For example, as hinted in one of the earlier sections, `<A HREF="javascript&#09;:alert(1)">` may need to be parsed as an absolute reference to `javascript<TAB>:alert(1)`, as opposed to a link to something called `javascript&` with a local URL hash string part of `#09;alert(1)`.

Unfortunately, various browsers follow different parsing rules to these HTML entity notations; all rendering engines recognize entities with no proper `;` terminator, and all permit entities with excessively long, zero-padded notation, but with various thresholds:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Maximum length of a correctly terminated decimal entity</font> || <font color="#ff0000">7</font> || <font color="#ff0000">7</font> || || <font color="#ff0000">âˆž</font> || <font color="#ff0000">âˆž</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">âˆž</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">8</font>^*^ ||
|| <font color="#3050a0">Maximum length of an incorrectly terminated decimal entity</font> || <font color="#ff0000">7</font> || <font color="#ff0000">7</font> || || <font color="#ff0000">âˆž</font> || <font color="#ff0000">âˆž</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">âˆž</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">8</font>^*^ ||
|| <font color="#3050a0">Maximum length of a correctly terminated hex entity</font> || <font color="#ff0000">6</font> || <font color="#ff0000">6</font> || || <font color="#ff0000">âˆž</font> || <font color="#ff0000">âˆž</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">âˆž</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">8</font>^*^ ||
|| <font color="#3050a0">Maximum length of an incorrectly terminated hex entity</font> || 0 || 0 || || <font color="#ff0000">âˆž</font> || <font color="#ff0000">âˆž</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">âˆž</font> || <font color="#ff0000">8</font>^*^ || <font color="#ff0000">8</font>^*^ ||
|| <font color="#3050a0">Characters permitted in entity names]] (excluding `A-Z a-z 0-9`)</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || || <font color="#ff0000">- . _</font> || <font color="#ff0000">- . _</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#909090">none</font> || <font color="#909090">none</font> ||

_^*^ Entries one byte longer than this limit still get parsed, but incorrectly; for example, `&#000000065;` becomes a sequence of three characters, `\x06 5 ;`. Two characters and more do not get parsed at all - `&#0000000065;` is displayed literally)._

An interesting piece of trivia is that as per HTML entity encoding requirements, links such as:

{{{
http://example.com/?p1=v1&p2=v2
}}}

Should be technically always encoded in HTML parameters (but not in Javascript code) as:

{{{
<a href="http://example.com/?p1=v1&amp;p2=v2">Click here</a>
}}}

In practice, however, the convention is almost never followed by web developers, and browsers compensate for it by treating invalid HTML entities as literal `&`-containing strings.

==Document Object Model==

As the Web matured and the concept of client-side programming gained traction, the need arose for HTML document to be programatically accessible and modifiable on the fly in response to user actions. One technology, [http://www.w3.org/DOM/DOMTR Document Object Model] (also referred to as "dynamic HTML"), emerged as the prevailing method for accomplishing this task.

In the context of web browsers, Document Object Model is simply an object-based representation of HTML document layout, and by a natural extension much of the browser internals, in a hierarchical structure with various read and write properties, and callable methods. To illustrate, to access the value of the first `<INPUT>` tag in a document through DOM, the following Javascript code could be used:

{{{
document.getElementsByTagName('INPUT')[0].value
}}}

Document Object Model also permits third-party documents to be referenced, subject to certain security checks discussed later on; for example, the following code accesses the `<INPUT>` tag in the second `<IFRAME>` on a current page:

{{{
document.getElementsByTagName('IFRAME')[1].contentDocument.getElementsByTagName('INPUT')[0].value
}}}

DOM object hierarchy - as seen by programmers - begins with an implicit "root" object, sometimes named `defaultView` or `global`; all the scripts running on a page have `defaultView` as their default scope. This root object has the following members:

  * Various properties and methods relating to current document-specific window or frame ([http://www.w3schools.com/HTMLDOM/dom_obj_window.asp reference]). Properties include window dimensions, status bar text, references to parent, top-level, and owner (opener) `defaultView` objects. Methods permit scripts to resize, move, change focus, or decor of current windows, display certain UI widgets, or - oddly enough - set up Javascript timers to execute code after a certain "idle" interval.

  * All the current script's global variables and functions.

  * `defaultView.document` ([http://www.w3schools.com/HTMLDOM/dom_obj_document.asp reference]) - a top-level object for the actual, proper _document_ object model. This hierarchy represents all of the document elements, along with their specific methods and properties, and document-wide object lookup functions (e.g., `getElementById`, `getElementsByTagName`, etc).

  * `defaultView.location` ([http://www.w3schools.com/HTMLDOM/dom_obj_location.asp reference]) - a simple object describing document's current location, both as an unparsed string, and split into parsed segments; provides methods and property setters that allow scripts to navigate away to other sites.

  * `defaultView.history` ([http://www.w3schools.com/HTMLDOM/dom_obj_history.asp reference]) - another simple object offering three methods to enable pages to navigate back to previously visited pages.

  * `defaultView.screen` ([http://www.w3schools.com/HTMLDOM/dom_obj_screen.asp reference]) - yet another modestly sized object with a bunch of mostly read-only properties describing properties of the current display device, including pixel and DPI resolution, and so forth.

  * `defaultView.navigator` ([http://www.w3schools.com/HTMLDOM/dom_obj_navigator.asp reference]) - an object containing read-only properties such as browser make and version, operating platform, or plugin configuration.

  * `defaultView.window` - a self-referential entry that points back to the root object; this is the name by which the `defaultView` object is most commonly known. In general, `screen`, `navigator`, and `window` DOM hierarchies combined usually contain enough information to very accurately fingerprint any given machine.

With the exception of cross-domain, cross-document access permissions outlined in later chapters, the operation of DOM bears relatively little significance to site security. It is, however, worth noting that DOM methods are wrappers providing access to highly implementation-specific internal data structures that may or may not obey the usual rules of Javascript language. Because of this, multiple seemingly inexplicable oddities and quirks plague DOM data structures in every browsers - and some of these may interfere with client-side security mechanisms. Several such quirks are documented below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is `window` the same object as `window.window`?</font> || <font color="#ff0000">NO</font> || <font color="#ff0000">NO</font> || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is `document.URL` writable?</font> || NO || <font color="#ff0000">YES</font> || || NO || NO || NO || NO || NO || NO ||
|| <font color="#3050a0">Can builtin DOM objects be clobbered?</font> || shadowing || shadowing || || shadowing || shadowing || shadowing || shadowing || shadowing || shadowing ||

_Trivia: traversing `document.*` is a possible approach to look up specific input or output fields when modifying complex pages from within scripts, but it is not a very practical one; because of this, most scripts resort to `document.getElementById()` method to uniquely identify elements regardless of their current location on the page. Although `ID=` parameters for tags within HTML documents are expected to be unique, there is no such guarantee. Currently, all major browsers seem to give the first occurrence a priority._

==Browser-side Javascript==

[http://en.wikipedia.org/wiki/Javascript Javascript] is a relatively simple but rich, object-based imperative scripting language tightly integrated with HTML, and supported by all contemporary web browsers. Authors claim that the language has roots with [http://en.wikipedia.org/wiki/Scheme_(programming_language) Scheme] and [http://en.wikipedia.org/wiki/Self_(programming_language) Self] programming languages, although it is often characterized in a more down-to-earth way as resembling a crossover of [http://en.wikipedia.org/wiki/Objective-C Objective C] and [http://en.wikipedia.org/wiki/Visual_Basic Visual Basic]. Confusingly, except for the common C syntax, it shares relatively few unique features with [http://en.wikipedia.org/wiki/Java_(programming_language) Java]; the naming is simply a marketing gimmick devised by Netscape and Sun in the 90s.

The language is a creation of Netscape engineers, originally marketed under the name of Mocha, then Livescript, and finally rebranded to Javascript; Microsoft embraced the concept shortly thereafter, under the name of JScript. The language, as usual with web technologies, got standardized only post factum, under a yet another name - ECMAScript. Additional, sometimes overlapping efforts to bring new features and extensions of the language - for example, [http://wiki.ecmascript.org/doku.php ECMAScript 4], [http://developer.mozilla.org/Special:Tags?tag=JavaScript_version_overviews&language=en Javascript versions 1.6-1.8], [http://developer.mozilla.org/En/E4X native XML objects], etc - are taking place, although neither of these concepts managed to win broad acceptance and following.

Browser-side Javascript is invoked from within HTML documents in four primary ways: 

  # Standalone `<SCRIPT>` tags that enclose code blocks,
  # Event handlers tied to HTML tags (e.g. `onmouseover="..."`),
  # Stylesheet `expression(...)` blocks that permit Javascript syntax in some browsers,
  # Special URL schemes specified as targets for certain resources or actions (`javascript:...`),

Note that the first option does not always work when such a string is dynamically added by running Javascript to an existing document. That said, any of the remaining options might be used as a comparable substitute.

Regardless of their source (`<SCRIPT SRC="...">`), remote scripts always execute in the security context of the document they are attached to. As noted earlier, once called, Javascript has full access to the current DOM, and limited access to DOMs of other windows; it may also further invoke new Javascript by calling `eval()`, configuring timers (`setTimeout(...)` and `setInterval(...)`), or producing Javascript-invoking HTML. Javascript may also configure self to launch when its objects are interacted with by third-party Javascript code, by configuring watches, setters, or getters, or cross contexts by calling same-origin functions belonging to other documents.

Javascript enjoys very limited input and output capabilities. Interacting with same-origin document data and drawing [http://developer.mozilla.org/en/Canvas_tutorial CANVASes], displaying `window.*` pop-up dialogs, and writing script console errors aside, there are relatively few I/O facilities available. File operations or access to other persistent storage is generally not possible, although some [https://developer.mozilla.org/en/DOM/Storage experimental features] are being experimented with. Scripts may send and receive data from the originating server using the [http://www.w3.org/TR/XMLHttpRequest/ XMLHttpRequest] extension, which permits scripts to send and read arbitrary payloads; and may also automatically send requests and read back properly-formatted responses by issuing `<SCRIPT SRC="...">`, or `<LINK REL="Stylesheet" HREF="...">`, even across domains. Lastly, Javascript may send information to third-party servers by spawning objects such as `<IMG>`, `<IFRAME>`, `<OBJECT>`, `<APPLET>`, or by triggering page transitions, and encoding information in the URL that would be automatically requested by the browser immediately thereafter - but it may not read back the returned data. Some side channels related to browser caching mechanisms and lax DOM security checks also exist, providing additional side channels between cooperating parties.

Some of the other security-relevant characteristics of Javascript environments in modern browsers include:

  * *Dynamic, runtime code interpretation with no strict code caching rules*. Any code snippets located in-line with HTML tags would be interpreted and executed, and Javascript itself has a possibility to either directly evaluate strings as Javascript code (`eval(...)`), or to produce new HTML that in turn may contain more Javascript (`.innerHTML` and `.outerHTML` properties, `document.write()`, event handlers). The behavior of code that attempts to modify own container while executing (through DOM) is not well-defined, and varies between browsers.

  * *Somewhat inconsistent exception support*. Although within the language itself, exception-throwing conditions are well defined, it is not so when interacting with DOM structures. Depending on the circumstances, some DOM operations may fail silently (with writes or reads ignored), return various magic responses (`undefined`, `null`, `object inaccessible`), throw a non-standardized exception, or even abort execution unconditionally.

  * *Somewhat inconsistent, but modifiable builtins and prototypes*. The behavior of many language constructs might be redefined by programs within the current context by modifying object setters, getters, or overwriting prototypes. Because of this, reliance on any specific code - for example a security check - executing in a predictable manner in the vicinity of a potentially malicious payload is risky. Notably, however, not all builtin objects may be trivially tampered with - for example, `Array` prototype setters may be modifiable, but `XML` not so. There is no fully-fledged operator overloading in Javascript 1.x.

  * *Typically synchronous execution*. Within a single document, browser-side Javascript usually executes synchronously and in a single thread, and asynchronous timer events are not permitted to fire until the scripting engine enters idle state. No strict guarantees of synchronous execution exist, however, and multi-process rendering of Chrome or MSIE8 may permit cross-domain access to occur more asynchronously.

  * *Global function lookups not dependent on ordering or execution flow*. Functions may be invoked in a block of code before they are defined, and are indexed in a pass prior to execution. Because of this, reliance on top-level no-return statements such as `while (1);` to prevent subsequent code from being interpreted might be risky.

  * *Endless loops that terminate*. As a security feature, when the script executes for too long, the user is prompted to abort execution. This merely causes current execution to be stopped, but does not prevent scripts from being re-entered.

  * *Broad, quickly evolving syntax*. For example, E4X extensions in Firefox [http://code.google.com/p/doctype/wiki/ArticleE4XSecurity well-structured XHTML or XML to be interpreted] as a Javascript object, also executing any nested Javascript initializers within such a block. This makes it very difficult to assume that a particular format of data would not constitute valid Javascript syntax in a future-proof manner.

Inline script blocks embedded within HTML are somewhat tricky to sanitize if permitted to contain user-controlled strings, because, much like `<TEXTAREA>`, `<STYLE>`, and several other HTML tags, they follow a counterintuitive CDATA-style parsing: a literal sequence of `</SCRIPT>` ends the script block regardless of its location within the Javascript syntax as such. For example, the following code block would be ended prematurely, and lead to unauthorized, additional Javascript block being executed:

{{{
<SCRIPT>
var user_string = 'Hello world</SCRIPT><SCRIPT>alert(1)</SCRIPT>';
</SCRIPT>
}}}

Various differences between browser implementations are outlined below:

|| <font color="#3050a0">*Test description*</font> || <font color="#3050a0">*MSIE6*</font> || <font color="#3050a0">*MSIE7*</font> || <font color="#3050a0">*MSIE8*</font> || <font color="#3050a0">*FF2*</font> || <font color="#3050a0">*FF3*</font> || <font color="#3050a0">*Safari*</font> || <font color="#3050a0">*Opera*</font> || <font color="#3050a0">*Chrome*</font> || <font color="#3050a0">*Android*</font> ||
|| <font color="#3050a0">Is setter and getter support present?</font> || NO || NO || || YES || YES || YES || YES || YES || YES ||
|| <font color="#3050a0">Is access to prototypes via `__proto__` possible?</font> || NO || NO || || YES || YES || YES || NO || YES || YES ||
|| <font color="#3050a0">Is it possible to alias `eval()` function? || YES || YES || || PARTLY || PARTLY || YES || PARTLY || NO || YES ||
|| <font color="#3050a0">Are watches on objects supported?</font> || NO || NO || || YES || YES || NO || NO || NO || NO ||
|| <font color="#3050a0">May currently executing code blocks modify self?</font> || read-only || read-only || || NO || NO || NO || YES || NO || NO ||
|| <font color="#3050a0">Is E4X extension supported?</font> || NO || NO || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || NO || NO || NO ||
|| <font color="#3050a0">Is `charset=` honored on `<SCRIPT SRC="...">`?</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> || NO || <font color="#ff0000">YES</font> || <font color="#ff0000">YES</font> ||
